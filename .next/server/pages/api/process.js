"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/process";
exports.ids = ["pages/api/process"];
exports.modules = {

/***/ "fluent-ffmpeg":
/*!********************************!*\
  !*** external "fluent-ffmpeg" ***!
  \********************************/
/***/ ((module) => {

module.exports = require("fluent-ffmpeg");

/***/ }),

/***/ "google-tts-api":
/*!*********************************!*\
  !*** external "google-tts-api" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("google-tts-api");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

module.exports = require("child_process");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ }),

/***/ "@google/generative-ai":
/*!****************************************!*\
  !*** external "@google/generative-ai" ***!
  \****************************************/
/***/ ((module) => {

module.exports = import("@google/generative-ai");;

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fprocess&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cprocess.js&middlewareConfigBase64=e30%3D!":
/*!********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fprocess&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cprocess.js&middlewareConfigBase64=e30%3D! ***!
  \********************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_process_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages\\api\\process.js */ \"(api)/./pages/api/process.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_pages_api_process_js__WEBPACK_IMPORTED_MODULE_3__]);\n_pages_api_process_js__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_process_js__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_process_js__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/process\",\n        pathname: \"/api/process\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _pages_api_process_js__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRnByb2Nlc3MmcHJlZmVycmVkUmVnaW9uPSZhYnNvbHV0ZVBhZ2VQYXRoPS4lMkZwYWdlcyU1Q2FwaSU1Q3Byb2Nlc3MuanMmbWlkZGxld2FyZUNvbmZpZ0Jhc2U2ND1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXNHO0FBQ3ZDO0FBQ0w7QUFDMUQ7QUFDcUQ7QUFDckQ7QUFDQSxpRUFBZSx3RUFBSyxDQUFDLGtEQUFRLFlBQVksRUFBQztBQUMxQztBQUNPLGVBQWUsd0VBQUssQ0FBQyxrREFBUTtBQUNwQztBQUNPLHdCQUF3QixnSEFBbUI7QUFDbEQ7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWTtBQUNaLENBQUM7O0FBRUQscUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWRlby1kdWJiZXIvPzhiZDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFnZXNBUElSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL3BhZ2VzLWFwaS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBob2lzdCB9IGZyb20gXCJuZXh0L2Rpc3QvYnVpbGQvdGVtcGxhdGVzL2hlbHBlcnNcIjtcbi8vIEltcG9ydCB0aGUgdXNlcmxhbmQgY29kZS5cbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIuL3BhZ2VzXFxcXGFwaVxcXFxwcm9jZXNzLmpzXCI7XG4vLyBSZS1leHBvcnQgdGhlIGhhbmRsZXIgKHNob3VsZCBiZSB0aGUgZGVmYXVsdCBleHBvcnQpLlxuZXhwb3J0IGRlZmF1bHQgaG9pc3QodXNlcmxhbmQsIFwiZGVmYXVsdFwiKTtcbi8vIFJlLWV4cG9ydCBjb25maWcuXG5leHBvcnQgY29uc3QgY29uZmlnID0gaG9pc3QodXNlcmxhbmQsIFwiY29uZmlnXCIpO1xuLy8gQ3JlYXRlIGFuZCBleHBvcnQgdGhlIHJvdXRlIG1vZHVsZSB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG5leHBvcnQgY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgUGFnZXNBUElSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuUEFHRVNfQVBJLFxuICAgICAgICBwYWdlOiBcIi9hcGkvcHJvY2Vzc1wiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL3Byb2Nlc3NcIixcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBhcmVuJ3QgdXNlZCBpbiBwcm9kdWN0aW9uLlxuICAgICAgICBidW5kbGVQYXRoOiBcIlwiLFxuICAgICAgICBmaWxlbmFtZTogXCJcIlxuICAgIH0sXG4gICAgdXNlcmxhbmRcbn0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdlcy1hcGkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fprocess&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cprocess.js&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./pages/api/process.js":
/*!******************************!*\
  !*** ./pages/api/process.js ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var fluent_ffmpeg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fluent-ffmpeg */ \"fluent-ffmpeg\");\n/* harmony import */ var fluent_ffmpeg__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fluent_ffmpeg__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! child_process */ \"child_process\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _google_generative_ai__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @google/generative-ai */ \"@google/generative-ai\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_google_generative_ai__WEBPACK_IMPORTED_MODULE_5__]);\n_google_generative_ai__WEBPACK_IMPORTED_MODULE_5__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n// pages/api/process.js\n\n\n\n // Import exec for ffprobe and atempo stretching\n\n\nconst execAsync = (0,util__WEBPACK_IMPORTED_MODULE_4__.promisify)(child_process__WEBPACK_IMPORTED_MODULE_3__.exec); // Promisify exec for easier async/await usage\nconst config = {\n    api: {\n        responseLimit: false,\n        bodyParser: false\n    }\n};\nasync function handler(req, res) {\n    if (req.method !== \"POST\") {\n        return res.status(405).json({\n            message: \"Method not allowed\"\n        });\n    }\n    // --- Manually parse the JSON body ---\n    let body = \"\";\n    req.on(\"data\", (chunk)=>{\n        body += chunk.toString();\n    });\n    await new Promise((resolve, reject)=>{\n        req.on(\"end\", resolve);\n        req.on(\"error\", reject);\n    });\n    let { videoId, sourceLang, targetLang } = {};\n    try {\n        const parsedBody = JSON.parse(body);\n        videoId = parsedBody.videoId;\n        sourceLang = parsedBody.sourceLang;\n        targetLang = parsedBody.targetLang;\n    } catch (e) {\n        console.error(\"Error parsing JSON body in process.js:\", e);\n        return res.status(400).json({\n            message: \"Invalid JSON in request body\"\n        });\n    }\n    // --- END Manual Parsing ---\n    if (!videoId || !sourceLang || !targetLang) {\n        console.error(\"Missing required parameters:\", {\n            videoId,\n            sourceLang,\n            targetLang\n        });\n        return res.status(400).json({\n            message: \"Missing videoId, sourceLang, or targetLang\"\n        });\n    }\n    const tempDir = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), \"temp_uploads\");\n    const metadataPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(tempDir, `${videoId}_metadata.json`);\n    const videoPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(tempDir, `${videoId}.mp4`);\n    if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(metadataPath) || !fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(videoPath)) {\n        console.error(\"Files not found:\", {\n            metadataPath: fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(metadataPath),\n            videoPath: fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(videoPath)\n        });\n        return res.status(404).json({\n            message: \"Video or metadata not found\"\n        });\n    }\n    try {\n        // --- PHASE 1: Audio Extraction ---\n        console.log(`[${videoId}] Starting Phase 1: Audio Extraction`);\n        const audioPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(tempDir, `${videoId}_audio.wav`);\n        await new Promise((resolve, reject)=>{\n            fluent_ffmpeg__WEBPACK_IMPORTED_MODULE_2___default()(videoPath).toFormat(\"wav\") // Ensure output is WAV for Whisper/ASR\n            .audioChannels(1) // Mono for Whisper/ASR\n            .audioFrequency(16000) // 16kHz for Whisper/ASR\n            .output(audioPath).on(\"end\", ()=>{\n                console.log(`[${videoId}] Audio extracted: ${audioPath}`);\n                resolve();\n            }).on(\"error\", (err)=>{\n                console.error(`[${videoId}] FFmpeg Error during extraction:`, err);\n                reject(err);\n            }).run();\n        });\n        // --- PHASE 2: ASR -> Translation -> TTS -> Sync Adjustment ---\n        console.log(`[${videoId}] Starting Phase 2: ASR -> Translation -> TTS -> Sync Adjustment`);\n        const dubbedAudioPath_MP3 = path__WEBPACK_IMPORTED_MODULE_1___default().join(tempDir, `${videoId}_dubbed_audio.mp3`); // Output path for raw TTS audio (MP3)\n        const dubbedAudioPathAdjusted_MP3 = path__WEBPACK_IMPORTED_MODULE_1___default().join(tempDir, `${videoId}_dubbed_audio_adjusted.mp3`); // Output path for time-stretched audio (MP3)\n        // Step 1: ASR (AssemblyAI - FREE Tier Available)\n        console.log(`[${videoId}] Calling AssemblyAI ASR...`);\n        const transcribedText = await transcribeAudioWithAssemblyAI(audioPath, sourceLang);\n        console.log(`[${videoId}] ASR Result:`, transcribedText);\n        // Step 2: Translation (Gemini API - Cost Incurred) - Dubbing Focused Prompt\n        console.log(`[${videoId}] Calling Gemini for Dubbing-Focused Translation...`);\n        const translatedText = await translateWithGemini(transcribedText, sourceLang, targetLang);\n        console.log(`[${videoId}] Translation Result:`, translatedText);\n        // Step 3: TTS (ElevenLabs - Cost Incurred via API usage, Falls back to Google TTS if no key)\n        console.log(`[${videoId}] Calling TTS (ElevenLabs or Google TTS)...`);\n        await generateTTSWithElevenLabs(translatedText, dubbedAudioPath_MP3, targetLang); // Pass the .mp3 path\n        console.log(`[${videoId}] TTS Audio Generated: ${dubbedAudioPath_MP3}`);\n        // Step 4: Sync Adjustment (Time-Stretch TTS Audio to Match Original Duration)\n        console.log(`[${videoId}] Adjusting TTS Audio Duration to Match Original...`);\n        await adjustAudioDurationWithFFmpeg(audioPath, dubbedAudioPath_MP3, dubbedAudioPathAdjusted_MP3); // Pass original, raw TTS, and target adjusted paths\n        console.log(`[${videoId}] TTS Audio Duration Adjusted: ${dubbedAudioPathAdjusted_MP3}`);\n        // --- PHASE 3: Merging Audio with Video ---\n        console.log(`[${videoId}] Starting Phase 3: Merging Adjusted Dubbed Audio`);\n        const outputPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(tempDir, `${videoId}_dubbed.mp4`);\n        // Use a Promise to handle the FFmpeg merge process correctly with explicit mapping\n        await new Promise((resolve, reject)=>{\n            const ffmpegCommand = fluent_ffmpeg__WEBPACK_IMPORTED_MODULE_2___default()(videoPath) // Input video file (contains original audio)\n            .input(dubbedAudioPathAdjusted_MP3) // Input adjusted TTS audio file (.mp3)\n            .outputOptions([\n                \"-map\",\n                \"0:v\",\n                \"-map\",\n                \"1:a\",\n                \"-c:v\",\n                \"copy\",\n                \"-c:a\",\n                \"aac\",\n                \"-strict\",\n                \"experimental\"\n            ]).output(outputPath);\n            ffmpegCommand.on(\"start\", (cmd)=>{\n                console.log(`FFmpeg merge command started: ${cmd}`);\n            }).on(\"progress\", (progress)=>{\n            // Optional: Log progress\n            // console.log(`FFmpeg merge progress: frame=${progress.frame}, timemark=${progress.timemark}, fps=${progress.fps}`);\n            }).on(\"end\", (stdout, stderr)=>{\n                console.log(`[${videoId}] Merging completed: ${outputPath}`);\n                if (stderr) {\n                    console.warn(`[${videoId}] FFmpeg merge stderr (warnings): ${stderr}`); // Log warnings\n                }\n                // Clean up intermediate files after successful merge\n                fs__WEBPACK_IMPORTED_MODULE_0___default().unlink(dubbedAudioPath_MP3, (err)=>{\n                    if (err) console.error(`[${videoId}] Error deleting raw TTS file:`, err);\n                    else console.log(`[${videoId}] Deleted raw TTS file: ${dubbedAudioPath_MP3}`);\n                });\n                resolve(); // Resolve the promise on successful end\n            }).on(\"error\", (err, stdout, stderr)=>{\n                console.error(`[${videoId}] FFmpeg ERROR during merge:`, err.message);\n                console.error(`[${videoId}] FFmpeg merge stdout:`, stdout); // Log stdout in case of error\n                console.error(`[${videoId}] FFmpeg merge stderr:`, stderr); // Log stderr in case of error\n                reject(err); // Reject the promise on error\n            }).run();\n        });\n        // Update metadata status\n        const metadata = JSON.parse(await fs__WEBPACK_IMPORTED_MODULE_0___default().promises.readFile(metadataPath, \"utf8\"));\n        metadata.status = \"completed\";\n        metadata.outputPath = outputPath;\n        metadata.processedTimestamp = new Date().toISOString();\n        await fs__WEBPACK_IMPORTED_MODULE_0___default().promises.writeFile(metadataPath, JSON.stringify(metadata));\n        res.status(200).json({\n            message: \"Processing successful\",\n            videoId,\n            status: \"completed\"\n        });\n    } catch (error) {\n        console.error(`[${videoId}] Processing Error:`, error);\n        try {\n            const metadata = JSON.parse(await fs__WEBPACK_IMPORTED_MODULE_0___default().promises.readFile(metadataPath, \"utf8\"));\n            metadata.status = \"failed\";\n            metadata.error = error.message;\n            await fs__WEBPACK_IMPORTED_MODULE_0___default().promises.writeFile(metadataPath, JSON.stringify(metadata));\n        } catch (metaErr) {\n            console.error(`[${videoId}] Failed to update metadata on error:`, metaErr);\n        }\n        res.status(500).json({\n            message: \"Processing failed\",\n            error: error.message\n        });\n    }\n}\n// --- ASR Function using AssemblyAI (FREE Tier Available) ---\nasync function transcribeAudioWithAssemblyAI(audioFilePath, sourceLang) {\n    const ASSEMBLYAI_API_KEY = process.env.ASSEMBLYAI_API_KEY;\n    if (!ASSEMBLYAI_API_KEY) {\n        throw new Error(\"ASSEMBLYAI_API_KEY environment variable is required for AssemblyAI ASR.\");\n    }\n    const endpoint = \"https://api.assemblyai.com/v2\"; // Corrected endpoint (removed trailing spaces)\n    // Step 1: Upload the audio file\n    console.log(\"Uploading audio to AssemblyAI...\");\n    const audioData = fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(audioFilePath);\n    const uploadResponse = await fetch(`${endpoint}/upload`, {\n        method: \"POST\",\n        body: audioData,\n        headers: {\n            \"Authorization\": ASSEMBLYAI_API_KEY\n        }\n    });\n    if (!uploadResponse.ok) {\n        const errorText = await uploadResponse.text();\n        console.error(\"AssemblyAI Upload Error:\", uploadResponse.status, errorText);\n        throw new Error(`AssemblyAI Upload failed: ${uploadResponse.status} - ${errorText}`);\n    }\n    const uploadData = await uploadResponse.json();\n    const audioUrl = uploadData.upload_url;\n    console.log(\"Audio uploaded successfully. URL:\", audioUrl);\n    // Step 2: Request transcription\n    console.log(\"Requesting transcription from AssemblyAI...\");\n    const transcribeResponse = await fetch(`${endpoint}/transcript`, {\n        method: \"POST\",\n        body: JSON.stringify({\n            audio_url: audioUrl\n        }),\n        headers: {\n            \"Authorization\": ASSEMBLYAI_API_KEY,\n            \"Content-Type\": \"application/json\"\n        }\n    });\n    if (!transcribeResponse.ok) {\n        const errorText = await transcribeResponse.text();\n        console.error(\"AssemblyAI Transcribe Request Error:\", transcribeResponse.status, errorText);\n        throw new Error(`AssemblyAI Transcribe Request failed: ${transcribeResponse.status} - ${errorText}`);\n    }\n    const transcribeData = await transcribeResponse.json();\n    const transcriptId = transcribeData.id;\n    console.log(\"Transcription request submitted. ID:\", transcriptId);\n    // Step 3: Poll for completion\n    console.log(\"Polling for transcription completion...\");\n    let pollingEndpoint = `${endpoint}/transcript/${transcriptId}`;\n    let result;\n    while(true){\n        const pollResponse = await fetch(pollingEndpoint, {\n            headers: {\n                \"Authorization\": ASSEMBLYAI_API_KEY\n            }\n        });\n        if (!pollResponse.ok) {\n            const errorText = await pollResponse.text();\n            console.error(\"AssemblyAI Polling Error:\", pollResponse.status, errorText);\n            throw new Error(`AssemblyAI Polling failed: ${pollResponse.status} - ${errorText}`);\n        }\n        result = await pollResponse.json();\n        const status = result.status;\n        if (status === \"completed\") {\n            console.log(\"AssemblyAI transcription completed.\");\n            break; // Exit the loop\n        } else if (status === \"error\") {\n            console.error(\"AssemblyAI transcription failed:\", result.error);\n            throw new Error(`AssemblyAI Transcription Error: ${result.error}`);\n        } else {\n            await new Promise((resolve)=>setTimeout(resolve, 3000)); // Wait 3 seconds before next poll\n        }\n    }\n    // Return the transcribed text\n    if (result.text !== undefined) {\n        console.log(\"Raw AssemblyAI Result:\", {\n            text: result.text,\n            confidence: result.confidence\n        });\n        return result.text.trim();\n    } else {\n        console.error(\"Unexpected AssemblyAI response format:\", result);\n        throw new Error(\"AssemblyAI returned unexpected data format.\");\n    }\n}\n// --- Translation Function using Google Gemini API (2.5 Flash) - Dubbing Focused ---\nasync function translateWithGemini(text, sourceLang, targetLang) {\n    const GEMINI_API_KEY = process.env.GEMINI_API_KEY;\n    if (!GEMINI_API_KEY) {\n        throw new Error(\"GEMINI_API_KEY environment variable is required for Gemini Translation.\");\n    }\n    // Initialize the Google AI SDK client\n    const genAI = new _google_generative_ai__WEBPACK_IMPORTED_MODULE_5__.GoogleGenerativeAI(GEMINI_API_KEY);\n    // Use the available model: gemini-2.5-flash (or gemini-2.5-pro, gemini-flash-latest, gemini-pro-latest)\n    // Based on the model listing you provided, gemini-2.5-flash is available and supports generateContent.\n    const model = genAI.getGenerativeModel({\n        model: \"gemini-2.5-flash\"\n    }); // Updated model name\n    // Craft the prompt for translation, focused on dubbing\n    // Ask Gemini to translate while keeping the sentence structure and approximate word count similar\n    // to the original text to help with audio timing during dubbing.\n    const prompt = `\r\nYou are a translator tasked with preparing text for audio dubbing. Your goal is to translate the provided ${sourceLang} text into ${targetLang} while preserving the original sentence structure and rhythm as closely as possible. This is crucial for aligning the translated audio with the original video's timing.\r\n\r\nPlease follow these guidelines:\r\n1.  **Translate accurately:** Ensure the meaning of the original text is correctly conveyed.\r\n2.  **Preserve Structure:** Keep sentences broken up in a similar way. If the original has 3 sentences, aim for 3 translated sentences.\r\n3.  **Match Rhythm/Approximate Length:** Try to use a similar number of words and syllables where possible. Avoid making sentences significantly longer or shorter than the original. This helps the generated speech match the original audio's duration.\r\n4.  **Output Only Translation:** Provide only the translated text, nothing else.\r\n\r\nOriginal ${sourceLang} text:\r\n${text}\r\n`;\n    try {\n        console.log(`Calling Gemini API for dubbing-focused translation (Model: ${model.model}) from ${sourceLang} to ${targetLang}...`);\n        const result = await model.generateContent(prompt);\n        const response = await result.response;\n        const translatedText = response.text();\n        if (!translatedText) {\n            throw new Error(\"Gemini API returned empty translation text.\");\n        }\n        console.log(\"Raw Gemini Translation Response:\", response);\n        console.log(\"Final translated text for TTS:\", translatedText.trim());\n        return translatedText.trim(); // Return the translated text\n    } catch (error) {\n        console.error(\"Gemini Translation Error:\", error);\n        // Check for specific error details from the API\n        if (error.message) {\n            console.error(\"Gemini Error Message:\", error.message);\n        }\n        throw error;\n    }\n}\n// --- TTS Function: Generate Speech using ElevenLabs API (Primary) or Google Translate TTS (Fallback) ---\n// Uses the ElevenLabs API as primary, and falls back to an unofficial Google Translate TTS API if no ElevenLabs key is found.\n// Note: ElevenLabs restricts access from certain countries (e.g., Russia, Iran, North Korea, Belarus, Syria, Cuba, Crimea, Donetsk, Luhansk).\nasync function generateTTSWithElevenLabs(text, outputPath, targetLang) {\n    const ELEVENLABS_API_KEY = process.env.ELEVENLABS_API_KEY;\n    // Check if ElevenLabs API key exists\n    if (ELEVENLABS_API_KEY) {\n        console.log(\"Using ElevenLabs API for TTS.\");\n        await generateTTSWithElevenLabsAPI(text, outputPath, targetLang, ELEVENLABS_API_KEY);\n    } else {\n        console.log(\"ELEVENLABS_API_KEY not found. Falling back to unofficial Google Translate TTS.\");\n        await generateTTSWithGoogleTTS(text, outputPath, targetLang);\n    }\n}\n// --- Primary TTS Function: Generate Speech using ElevenLabs API ---\nasync function generateTTSWithElevenLabsAPI(text, outputPath, targetLang, apiKey) {\n    // ElevenLabs voice ID mapping - Updated with the correct Hindi voice ID\n    const voiceIdMap = {\n        \"hi\": \"jUjRbhZWoMK4aDciW36V\",\n        \"en\": \"21m00Tcm4TlvDq8ikWAM\",\n        \"es\": \"EXAVITQu4vr4xnSDxMaL\"\n    };\n    // Select voice ID based on target language, default to English if not found\n    const voiceId = voiceIdMap[targetLang] || voiceIdMap[\"en\"];\n    console.log(`Using ElevenLabs voice ID: ${voiceId} for target language: ${targetLang}`);\n    // Define the output format - Using MP3 as WAV is not supported by the API\n    // Options include: mp3_22050_32, mp3_24000_48, mp3_44100_32, mp3_44100_64, etc.\n    const outputFormat = \"mp3_22050_32\"; // Using MP3 format\n    const url = `https://api.elevenlabs.io/v1/text-to-speech/${voiceId.trim()}?optimize_streaming_latency=0&output_format=${outputFormat}`; // Corrected URL (removed trailing spaces)\n    const requestBody = {\n        text: text\n    };\n    try {\n        console.log(`Calling ElevenLabs TTS API for text: \"${text.substring(0, 30)}...\" using voice: ${voiceId} and format: ${outputFormat}`);\n        const response = await fetch(url, {\n            method: \"POST\",\n            headers: {\n                \"xi-api-key\": apiKey,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(requestBody)\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error(\"ElevenLabs TTS API Error:\", response.status, response.statusText, errorText);\n            throw new Error(`ElevenLabs TTS API Error: ${response.status} ${response.statusText} - ${errorText}`);\n        }\n        // Read the audio data from the response body (it's a stream)\n        const audioBuffer = Buffer.from(await response.arrayBuffer());\n        // Write the audio buffer to the specified output file path\n        // The output path will now be an .mp3 file, which is fine for FFmpeg merging\n        await fs__WEBPACK_IMPORTED_MODULE_0___default().promises.writeFile(outputPath, audioBuffer);\n        console.log(`ElevenLabs TTS audio saved to: ${outputPath}`);\n    } catch (error) {\n        console.error(`ElevenLabs TTS API Error in generateTTSWithElevenLabsAPI:`, error);\n        throw error;\n    }\n}\n// --- Fallback TTS Function: Generate Speech using Unofficial Google Translate TTS API (Handles Long Text) ---\nasync function generateTTSWithGoogleTTS(text, outputPath, targetLang) {\n    const translate = __webpack_require__(/*! google-tts-api */ \"google-tts-api\"); // Import the library\n    const lang = targetLang;\n    try {\n        console.log(`[GoogleTTS] Splitting and processing long text for TTS (language: ${lang})`);\n        // Use getAllAudioUrls to handle long text. This returns an array of URLs for chunks.\n        // It automatically splits the text based on the character limit.\n        const audioUrls = translate.getAllAudioUrls(text, {\n            lang: lang,\n            slow: false,\n            host: \"https://translate.google.com\",\n            timeout: 10000\n        });\n        console.log(`[GoogleTTS] Generated ${audioUrls.length} audio chunk(s).`);\n        // Fetch each audio chunk and store the buffers\n        const audioBuffers = [];\n        for(let i = 0; i < audioUrls.length; i++){\n            const chunkUrl = audioUrls[i].url; // Extract the URL from the object\n            console.log(`[GoogleTTS] Fetching chunk ${i + 1}/${audioUrls.length} from: ${chunkUrl.substring(0, 100)}...`); // Log first 100 chars of URL\n            const response = await fetch(chunkUrl);\n            if (!response.ok) {\n                throw new Error(`Google TTS Chunk ${i + 1} Error: ${response.status} ${response.statusText}`);\n            }\n            const buffer = Buffer.from(await response.arrayBuffer());\n            audioBuffers.push(buffer);\n        }\n        // Concatenate the audio buffers using FFmpeg\n        console.log(`[GoogleTTS] Concatenating ${audioBuffers.length} audio chunks using FFmpeg...`);\n        const tempConcatDir = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), \"temp_uploads\", \"tts_chunks\");\n        fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(tempConcatDir, {\n            recursive: true\n        }); // Create directory if it doesn't exist\n        // Write each chunk buffer to a temporary file\n        const tempChunkFiles = [];\n        for(let i = 0; i < audioBuffers.length; i++){\n            const chunkFileName = `chunk_${Date.now()}_${i}.mp3`;\n            const chunkFilePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(tempConcatDir, chunkFileName);\n            await fs__WEBPACK_IMPORTED_MODULE_0___default().promises.writeFile(chunkFilePath, audioBuffers[i]);\n            tempChunkFiles.push(chunkFilePath);\n        }\n        // Create a temporary file list for FFmpeg's concat demuxer\n        const fileListPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(tempConcatDir, `file_list_${Date.now()}.txt`);\n        const fileListContent = tempChunkFiles.map((file)=>`file '${file}'`).join(\"\\n\");\n        await fs__WEBPACK_IMPORTED_MODULE_0___default().promises.writeFile(fileListPath, fileListContent);\n        // Use FFmpeg to concatenate the files\n        const finalOutputPath = outputPath; // The final output path\n        await new Promise((resolve, reject)=>{\n            fluent_ffmpeg__WEBPACK_IMPORTED_MODULE_2___default()().input(fileListPath).inputOptions([\n                \"-f\",\n                \"concat\",\n                \"-safe\",\n                \"0\"\n            ]) // Input options for concat demuxer\n            .outputOptions([\n                \"-c\",\n                \"copy\"\n            ]) // Copy streams without re-encoding for speed\n            .output(finalOutputPath).on(\"start\", (cmd)=>{\n                console.log(`[GoogleTTS] FFmpeg concat command started: ${cmd}`);\n            }).on(\"end\", (stdout, stderr)=>{\n                console.log(`[GoogleTTS] FFmpeg concat completed: ${finalOutputPath}`);\n                if (stderr) {\n                    console.warn(`[GoogleTTS] FFmpeg concat stderr (warnings): ${stderr}`);\n                }\n                resolve();\n            }).on(\"error\", (err, stdout, stderr)=>{\n                console.error(`[GoogleTTS] FFmpeg concat ERROR:`, err.message);\n                console.error(`[GoogleTTS] FFmpeg concat stdout:`, stdout);\n                console.error(`[GoogleTTS] FFmpeg concat stderr:`, stderr);\n                reject(err);\n            }).run();\n        });\n        // Clean up temporary chunk files and the list file after successful concatenation\n        console.log(`[GoogleTTS] Cleaning up temporary chunk files and list...`);\n        try {\n            await fs__WEBPACK_IMPORTED_MODULE_0___default().promises.unlink(fileListPath);\n            for (const chunkFile of tempChunkFiles){\n                await fs__WEBPACK_IMPORTED_MODULE_0___default().promises.unlink(chunkFile);\n            }\n            // Optionally, remove the directory if it's empty\n            fs__WEBPACK_IMPORTED_MODULE_0___default().rmdirSync(tempConcatDir); // This will fail if directory is not empty, which is okay.\n        } catch (cleanupErr) {\n            console.error(`[GoogleTTS] Error cleaning up temporary files:`, cleanupErr);\n        // Depending on your needs, you might want to throw the error or just log it.\n        // For now, we just log it to avoid stopping the main process.\n        }\n        console.log(`[GoogleTTS] Final concatenated audio saved to: ${finalOutputPath}`);\n    } catch (error) {\n        console.error(`[GoogleTTS] Error in generateTTSWithGoogleTTS:`, error);\n        throw error; // Re-throw to be caught by the main handler\n    }\n}\n// --- Sync Adjustment Function: Manipulate TTS Audio to Fit Original Video Length (Precise) ---\n// This function gets the duration of the original video audio and the generated TTS audio.\n// It calculates the overall speed factor needed to make the TTS audio duration match the original.\n// It then applies the necessary 'rubberband' filter to change tempo and duration precisely,\n// keeping pitch constant. If 'rubberband' is not available, it falls back to chained 'atempo'\n// filters (0.5-2.0 range) and then ensures the exact duration using 'atrim' and 'apad'.\nasync function adjustAudioDurationWithFFmpeg(originalAudioPath, ttsAudioPath, outputPath) {\n    return new Promise(async (resolve, reject)=>{\n        try {\n            console.log(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] Starting precise audio duration adjustment to match original...`);\n            // 1. Get original audio duration using ffprobe\n            console.log(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] Getting original audio duration from: ${originalAudioPath}`);\n            const originalDurationCommand = `ffprobe -v quiet -show_entries format=duration -of csv=p=0 \"${originalAudioPath}\"`;\n            const { stdout: originalDurationOutput } = await execAsync(originalDurationCommand);\n            const originalDuration = parseFloat(originalDurationOutput.trim());\n            if (isNaN(originalDuration) || originalDuration <= 0) {\n                throw new Error(`Invalid original duration retrieved: ${originalDurationOutput.trim()}`);\n            }\n            console.log(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] Original audio duration: ${originalDuration.toFixed(3)}s`);\n            // 2. Get TTS audio duration using ffprobe\n            console.log(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] Getting TTS audio duration from: ${ttsAudioPath}`);\n            const ttsDurationCommand = `ffprobe -v quiet -show_entries format=duration -of csv=p=0 \"${ttsAudioPath}\"`;\n            const { stdout: ttsDurationOutput } = await execAsync(ttsDurationCommand);\n            const ttsDuration = parseFloat(ttsDurationOutput.trim());\n            if (isNaN(ttsDuration) || ttsDuration <= 0) {\n                throw new Error(`Invalid TTS duration retrieved: ${ttsDurationOutput.trim()}`);\n            }\n            console.log(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] TTS audio duration: ${ttsDuration.toFixed(3)}s`);\n            // 3. Calculate overall speed factor needed (target_duration / current_duration)\n            const overallSpeedFactor = originalDuration / ttsDuration;\n            console.log(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] Overall speed factor needed (original/tts): ${overallSpeedFactor.toFixed(4)}`);\n            // --- Method 1: Attempt using 'rubberband' for precise duration matching ---\n            // Rubberband is generally better for tempo/pitch shifting with quality.\n            // It can directly target a duration or tempo change.\n            const targetTempo = 1.0 / overallSpeedFactor; // If speed needs to be 1.2x, tempo should be 1/1.2 = 0.833x\n            console.log(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] Calculated target tempo for rubberband: ${targetTempo.toFixed(4)}x`);\n            const rubberbandCommand = `ffmpeg -i \"${ttsAudioPath}\" -af \"rubberband=tempo=${targetTempo.toFixed(4)}\" -y \"${outputPath}\"`;\n            try {\n                console.log(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] Attempting adjustment with rubberband: ${rubberbandCommand}`);\n                const { stdout: rbStdout, stderr: rbStderr } = await execAsync(rubberbandCommand);\n                if (rbStderr) {\n                    // Rubberband might output warnings/info here, log them.\n                    console.warn(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] FFmpeg rubberband stderr (warnings/info): ${rbStderr}`);\n                }\n                console.log(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] Rubberband adjustment completed.`);\n                // If rubberband command succeeds, the file should be at the target duration.\n                // We can optionally verify the duration here and correct further if needed.\n                // For now, assume it worked and resolve.\n                console.log(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] Audio duration adjustment (using rubberband) completed: ${outputPath}`);\n                resolve();\n                return; // Exit the function after successful rubberband adjustment\n            } catch (rbError) {\n                console.warn(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] FFmpeg rubberband failed (might not be available or supported):`, rbError.message);\n                console.log(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] Falling back to chained 'atempo' method...`);\n            // If rubberband fails, proceed to the fallback method below.\n            }\n            // --- Fallback Method 2: Chained 'atempo' + Duration Verification + Correction ---\n            // This handles cases where rubberband isn't available.\n            // Determine the sequence of 'atempo' filters required (range 0.5 to 2.0 per filter)\n            let atempoFilters = [];\n            let tempFactor = overallSpeedFactor;\n            if (tempFactor > 1) {\n                // Speeding up: Use factors up to 2.0\n                while(tempFactor > 1){\n                    const nextFactor = Math.min(2.0, tempFactor);\n                    atempoFilters.push(nextFactor);\n                    tempFactor /= nextFactor;\n                }\n            } else if (tempFactor < 1) {\n                // Slowing down: Use factors down to 0.5\n                while(tempFactor < 1){\n                    const nextFactor = Math.max(0.5, tempFactor);\n                    atempoFilters.push(nextFactor);\n                    tempFactor /= nextFactor;\n                }\n            }\n            const atempoFilterString = atempoFilters.map((f)=>`atempo=${f.toFixed(2)}`).join(\",\");\n            console.log(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] Calculated atempo filters for fallback: ${atempoFilterString || \"None (factor is 1.0)\"}`);\n            const tempAdjustedPath = `${outputPath}.temp_atempo.mp3`; // Temporary file for atempo output\n            let atempoCommand;\n            if (atempoFilterString) {\n                atempoCommand = `ffmpeg -i \"${ttsAudioPath}\" -af \"${atempoFilterString}\" -y \"${tempAdjustedPath}\"`;\n            } else {\n                // If no adjustment needed, just copy\n                console.log(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] No atempo adjustment needed (factor is 1.0), copying...`);\n                atempoCommand = `ffmpeg -i \"${ttsAudioPath}\" -c copy -y \"${tempAdjustedPath}\"`;\n            }\n            console.log(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] Executing atempo command: ${atempoCommand}`);\n            const { stdout: atempoStdout, stderr: atempoStderr } = await execAsync(atempoCommand);\n            if (atempoStderr) {\n                console.warn(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] FFmpeg atempo stderr (warnings/info): ${atempoStderr}`);\n            }\n            // --- Verify Duration and Correct ---\n            // Get the duration of the file after atempo adjustment\n            console.log(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] Verifying duration of atempo-adjusted file: ${tempAdjustedPath}`);\n            const adjustedDurationCommand = `ffprobe -v quiet -show_entries format=duration -of csv=p=0 \"${tempAdjustedPath}\"`;\n            const { stdout: adjustedDurationOutput } = await execAsync(adjustedDurationCommand);\n            const adjustedDuration = parseFloat(adjustedDurationOutput.trim());\n            if (isNaN(adjustedDuration) || adjustedDuration <= 0) {\n                throw new Error(`Invalid duration retrieved from adjusted file: ${adjustedDurationOutput.trim()}`);\n            }\n            console.log(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] Duration after atempo: ${adjustedDuration.toFixed(3)}s, Target: ${originalDuration.toFixed(3)}s`);\n            const durationDiff = originalDuration - adjustedDuration;\n            console.log(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] Duration difference (target - adjusted): ${durationDiff.toFixed(3)}s`);\n            // Now, apply a final filter to ensure the exact duration matches the original\n            // If it's too short (durationDiff > 0), use 'apad' to add silence at the end.\n            // If it's too long (durationDiff < 0), use 'atrim' to cut the end.\n            // If it's very close (e.g., within 0.01s), just copy or rename.\n            const tolerance = 0.01; // 10 milliseconds tolerance\n            if (Math.abs(durationDiff) < tolerance) {\n                console.log(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] Duration is within tolerance (${tolerance}s), no further adjustment needed.`);\n                // Move the temporary file to the final output path\n                await fs__WEBPACK_IMPORTED_MODULE_0___default().promises.rename(tempAdjustedPath, outputPath);\n                console.log(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] Audio duration adjustment completed (within tolerance): ${outputPath}`);\n                resolve();\n                return;\n            }\n            let finalCommand;\n            if (durationDiff > tolerance) {\n                // Audio is too short, pad with silence\n                console.log(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] Audio is too short, padding with ${durationDiff.toFixed(3)}s of silence.`);\n                finalCommand = `ffmpeg -i \"${tempAdjustedPath}\" -af \"apad=pad_dur=${durationDiff.toFixed(3)}\" -y \"${outputPath}\"`;\n            } else if (durationDiff < -tolerance) {\n                // Audio is too long, trim the end\n                console.log(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] Audio is too long, trimming ${Math.abs(durationDiff).toFixed(3)}s from the end.`);\n                finalCommand = `ffmpeg -i \"${tempAdjustedPath}\" -to ${originalDuration.toFixed(3)} -c copy -y \"${outputPath}\"`;\n            // Alternative using atrim filter: finalCommand = `ffmpeg -i \"${tempAdjustedPath}\" -af \"atrim=end=${originalDuration.toFixed(3)}\" -y \"${outputPath}\"`;\n            // Using -to with -c copy is often faster than re-encoding with atrim.\n            }\n            if (finalCommand) {\n                console.log(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] Executing final correction command: ${finalCommand}`);\n                const { stdout: finalStdout, stderr: finalStderr } = await execAsync(finalCommand);\n                if (finalStderr) {\n                    console.warn(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] FFmpeg final correction stderr (warnings/info): ${finalStderr}`);\n                }\n            }\n            // Clean up the temporary atempo file\n            try {\n                await fs__WEBPACK_IMPORTED_MODULE_0___default().promises.unlink(tempAdjustedPath);\n                console.log(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] Deleted temporary atempo file: ${tempAdjustedPath}`);\n            } catch (unlinkErr) {\n                console.error(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] Error deleting temporary file:`, unlinkErr);\n            // Depending on requirements, this might be a warning or an error.\n            // For now, we continue even if deletion fails.\n            }\n            console.log(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] Audio duration adjustment completed (with correction): ${outputPath}`);\n            resolve(); // Resolve the promise on successful completion\n        } catch (execError) {\n            console.error(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] FFmpeg exec Error in adjustAudioDurationWithFFmpeg:`, execError);\n            if (execError.stdout) {\n                console.error(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] FFmpeg stdout on error:`, execError.stdout);\n            }\n            if (execError.stderr) {\n                console.error(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] FFmpeg stderr on error:`, execError.stderr);\n            }\n            // Attempt to clean up the temporary file if it exists in case of an error\n            try {\n                await fs__WEBPACK_IMPORTED_MODULE_0___default().promises.unlink(`${outputPath}.temp_atempo.mp3`);\n                console.log(`[${path__WEBPACK_IMPORTED_MODULE_1___default().basename(outputPath, \".mp3\")}] Deleted temporary atempo file on error.`);\n            } catch (unlinkErr) {\n            // Ignore error during cleanup on error path\n            }\n            reject(execError);\n        }\n    });\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0EsMEVBQTBFO1lBQzFFLElBQUk7Z0JBQ0EsTUFBTWhFLGtEQUFXLENBQUNrRSxNQUFNLENBQUMsQ0FBQyxFQUFFVCxXQUFXLGdCQUFnQixDQUFDO2dCQUN4RHpCLFFBQVFTLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRXhDLG9EQUFhLENBQUN3RCxZQUFZLFFBQVEseUNBQXlDLENBQUM7WUFDaEcsRUFBRSxPQUFPMkksV0FBVztZQUNoQiw0Q0FBNEM7WUFDaEQ7WUFDQTVLLE9BQU82SztRQUNUO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpZGVvLWR1YmJlci8uL3BhZ2VzL2FwaS9wcm9jZXNzLmpzP2EwZGYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcGFnZXMvYXBpL3Byb2Nlc3MuanNcclxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcclxuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCBmZm1wZWcgZnJvbSAnZmx1ZW50LWZmbXBlZyc7XHJcbmltcG9ydCB7IGV4ZWMgfSBmcm9tICdjaGlsZF9wcm9jZXNzJzsgLy8gSW1wb3J0IGV4ZWMgZm9yIGZmcHJvYmUgYW5kIGF0ZW1wbyBzdHJldGNoaW5nXHJcbmltcG9ydCB7IHByb21pc2lmeSB9IGZyb20gJ3V0aWwnO1xyXG5pbXBvcnQgeyBHb29nbGVHZW5lcmF0aXZlQUkgfSBmcm9tIFwiQGdvb2dsZS9nZW5lcmF0aXZlLWFpXCI7XHJcblxyXG5jb25zdCBleGVjQXN5bmMgPSBwcm9taXNpZnkoZXhlYyk7IC8vIFByb21pc2lmeSBleGVjIGZvciBlYXNpZXIgYXN5bmMvYXdhaXQgdXNhZ2VcclxuXHJcbmV4cG9ydCBjb25zdCBjb25maWcgPSB7XHJcbiAgYXBpOiB7XHJcbiAgICByZXNwb25zZUxpbWl0OiBmYWxzZSwgLy8gRGlzYWJsZSA0TUIgbGltaXQgZm9yIHByb2Nlc3NpbmcgcG90ZW50aWFsbHkgbGFyZ2UgaW50ZXJtZWRpYXRlIGZpbGVzIGFuZCBkb3dubG9hZHNcclxuICAgIGJvZHlQYXJzZXI6IGZhbHNlLCAgICAvLyBEaXNhYmxlIGF1dG9tYXRpYyBib2R5IHBhcnNpbmcgLSB3ZSBoYW5kbGUgaXQgbWFudWFsbHlcclxuICB9LFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlcihyZXEsIHJlcykge1xyXG4gIGlmIChyZXEubWV0aG9kICE9PSAnUE9TVCcpIHtcclxuICAgIHJldHVybiByZXMuc3RhdHVzKDQwNSkuanNvbih7IG1lc3NhZ2U6ICdNZXRob2Qgbm90IGFsbG93ZWQnIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gLS0tIE1hbnVhbGx5IHBhcnNlIHRoZSBKU09OIGJvZHkgLS0tXHJcbiAgbGV0IGJvZHkgPSAnJztcclxuICByZXEub24oJ2RhdGEnLCBjaHVuayA9PiB7XHJcbiAgICBib2R5ICs9IGNodW5rLnRvU3RyaW5nKCk7XHJcbiAgfSk7XHJcblxyXG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIHJlcS5vbignZW5kJywgcmVzb2x2ZSk7XHJcbiAgICByZXEub24oJ2Vycm9yJywgcmVqZWN0KTtcclxuICB9KTtcclxuXHJcbiAgbGV0IHsgdmlkZW9JZCwgc291cmNlTGFuZywgdGFyZ2V0TGFuZyB9ID0ge307XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHBhcnNlZEJvZHkgPSBKU09OLnBhcnNlKGJvZHkpO1xyXG4gICAgdmlkZW9JZCA9IHBhcnNlZEJvZHkudmlkZW9JZDtcclxuICAgIHNvdXJjZUxhbmcgPSBwYXJzZWRCb2R5LnNvdXJjZUxhbmc7XHJcbiAgICB0YXJnZXRMYW5nID0gcGFyc2VkQm9keS50YXJnZXRMYW5nO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBhcnNpbmcgSlNPTiBib2R5IGluIHByb2Nlc3MuanM6JywgZSk7XHJcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBtZXNzYWdlOiAnSW52YWxpZCBKU09OIGluIHJlcXVlc3QgYm9keScgfSk7XHJcbiAgfVxyXG4gIC8vIC0tLSBFTkQgTWFudWFsIFBhcnNpbmcgLS0tXHJcblxyXG4gIGlmICghdmlkZW9JZCB8fCAhc291cmNlTGFuZyB8fCAhdGFyZ2V0TGFuZykge1xyXG4gICAgY29uc29sZS5lcnJvcignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXJzOicsIHsgdmlkZW9JZCwgc291cmNlTGFuZywgdGFyZ2V0TGFuZyB9KTtcclxuICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IG1lc3NhZ2U6ICdNaXNzaW5nIHZpZGVvSWQsIHNvdXJjZUxhbmcsIG9yIHRhcmdldExhbmcnIH0pO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgdGVtcERpciA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAndGVtcF91cGxvYWRzJyk7XHJcbiAgY29uc3QgbWV0YWRhdGFQYXRoID0gcGF0aC5qb2luKHRlbXBEaXIsIGAke3ZpZGVvSWR9X21ldGFkYXRhLmpzb25gKTtcclxuICBjb25zdCB2aWRlb1BhdGggPSBwYXRoLmpvaW4odGVtcERpciwgYCR7dmlkZW9JZH0ubXA0YCk7XHJcblxyXG4gIGlmICghZnMuZXhpc3RzU3luYyhtZXRhZGF0YVBhdGgpIHx8ICFmcy5leGlzdHNTeW5jKHZpZGVvUGF0aCkpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0ZpbGVzIG5vdCBmb3VuZDonLCB7IG1ldGFkYXRhUGF0aDogZnMuZXhpc3RzU3luYyhtZXRhZGF0YVBhdGgpLCB2aWRlb1BhdGg6IGZzLmV4aXN0c1N5bmModmlkZW9QYXRoKSB9KTtcclxuICAgIHJldHVybiByZXMuc3RhdHVzKDQwNCkuanNvbih7IG1lc3NhZ2U6ICdWaWRlbyBvciBtZXRhZGF0YSBub3QgZm91bmQnIH0pO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIC0tLSBQSEFTRSAxOiBBdWRpbyBFeHRyYWN0aW9uIC0tLVxyXG4gICAgY29uc29sZS5sb2coYFske3ZpZGVvSWR9XSBTdGFydGluZyBQaGFzZSAxOiBBdWRpbyBFeHRyYWN0aW9uYCk7XHJcbiAgICBjb25zdCBhdWRpb1BhdGggPSBwYXRoLmpvaW4odGVtcERpciwgYCR7dmlkZW9JZH1fYXVkaW8ud2F2YCk7XHJcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGZmbXBlZyh2aWRlb1BhdGgpXHJcbiAgICAgICAgLnRvRm9ybWF0KCd3YXYnKSAvLyBFbnN1cmUgb3V0cHV0IGlzIFdBViBmb3IgV2hpc3Blci9BU1JcclxuICAgICAgICAuYXVkaW9DaGFubmVscygxKSAvLyBNb25vIGZvciBXaGlzcGVyL0FTUlxyXG4gICAgICAgIC5hdWRpb0ZyZXF1ZW5jeSgxNjAwMCkgLy8gMTZrSHogZm9yIFdoaXNwZXIvQVNSXHJcbiAgICAgICAgLm91dHB1dChhdWRpb1BhdGgpXHJcbiAgICAgICAgLm9uKCdlbmQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHt2aWRlb0lkfV0gQXVkaW8gZXh0cmFjdGVkOiAke2F1ZGlvUGF0aH1gKTtcclxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdlcnJvcicsIChlcnIpID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgWyR7dmlkZW9JZH1dIEZGbXBlZyBFcnJvciBkdXJpbmcgZXh0cmFjdGlvbjpgLCBlcnIpO1xyXG4gICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5ydW4oKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIC0tLSBQSEFTRSAyOiBBU1IgLT4gVHJhbnNsYXRpb24gLT4gVFRTIC0+IFN5bmMgQWRqdXN0bWVudCAtLS1cclxuICAgIGNvbnNvbGUubG9nKGBbJHt2aWRlb0lkfV0gU3RhcnRpbmcgUGhhc2UgMjogQVNSIC0+IFRyYW5zbGF0aW9uIC0+IFRUUyAtPiBTeW5jIEFkanVzdG1lbnRgKTtcclxuICAgIGNvbnN0IGR1YmJlZEF1ZGlvUGF0aF9NUDMgPSBwYXRoLmpvaW4odGVtcERpciwgYCR7dmlkZW9JZH1fZHViYmVkX2F1ZGlvLm1wM2ApOyAvLyBPdXRwdXQgcGF0aCBmb3IgcmF3IFRUUyBhdWRpbyAoTVAzKVxyXG4gICAgY29uc3QgZHViYmVkQXVkaW9QYXRoQWRqdXN0ZWRfTVAzID0gcGF0aC5qb2luKHRlbXBEaXIsIGAke3ZpZGVvSWR9X2R1YmJlZF9hdWRpb19hZGp1c3RlZC5tcDNgKTsgLy8gT3V0cHV0IHBhdGggZm9yIHRpbWUtc3RyZXRjaGVkIGF1ZGlvIChNUDMpXHJcblxyXG4gICAgLy8gU3RlcCAxOiBBU1IgKEFzc2VtYmx5QUkgLSBGUkVFIFRpZXIgQXZhaWxhYmxlKVxyXG4gICAgY29uc29sZS5sb2coYFske3ZpZGVvSWR9XSBDYWxsaW5nIEFzc2VtYmx5QUkgQVNSLi4uYCk7XHJcbiAgICBjb25zdCB0cmFuc2NyaWJlZFRleHQgPSBhd2FpdCB0cmFuc2NyaWJlQXVkaW9XaXRoQXNzZW1ibHlBSShhdWRpb1BhdGgsIHNvdXJjZUxhbmcpO1xyXG4gICAgY29uc29sZS5sb2coYFske3ZpZGVvSWR9XSBBU1IgUmVzdWx0OmAsIHRyYW5zY3JpYmVkVGV4dCk7XHJcblxyXG4gICAgLy8gU3RlcCAyOiBUcmFuc2xhdGlvbiAoR2VtaW5pIEFQSSAtIENvc3QgSW5jdXJyZWQpIC0gRHViYmluZyBGb2N1c2VkIFByb21wdFxyXG4gICAgY29uc29sZS5sb2coYFske3ZpZGVvSWR9XSBDYWxsaW5nIEdlbWluaSBmb3IgRHViYmluZy1Gb2N1c2VkIFRyYW5zbGF0aW9uLi4uYCk7XHJcbiAgICBjb25zdCB0cmFuc2xhdGVkVGV4dCA9IGF3YWl0IHRyYW5zbGF0ZVdpdGhHZW1pbmkodHJhbnNjcmliZWRUZXh0LCBzb3VyY2VMYW5nLCB0YXJnZXRMYW5nKTtcclxuICAgIGNvbnNvbGUubG9nKGBbJHt2aWRlb0lkfV0gVHJhbnNsYXRpb24gUmVzdWx0OmAsIHRyYW5zbGF0ZWRUZXh0KTtcclxuXHJcbiAgICAvLyBTdGVwIDM6IFRUUyAoRWxldmVuTGFicyAtIENvc3QgSW5jdXJyZWQgdmlhIEFQSSB1c2FnZSwgRmFsbHMgYmFjayB0byBHb29nbGUgVFRTIGlmIG5vIGtleSlcclxuICAgIGNvbnNvbGUubG9nKGBbJHt2aWRlb0lkfV0gQ2FsbGluZyBUVFMgKEVsZXZlbkxhYnMgb3IgR29vZ2xlIFRUUykuLi5gKTtcclxuICAgIGF3YWl0IGdlbmVyYXRlVFRTV2l0aEVsZXZlbkxhYnModHJhbnNsYXRlZFRleHQsIGR1YmJlZEF1ZGlvUGF0aF9NUDMsIHRhcmdldExhbmcpOyAvLyBQYXNzIHRoZSAubXAzIHBhdGhcclxuICAgIGNvbnNvbGUubG9nKGBbJHt2aWRlb0lkfV0gVFRTIEF1ZGlvIEdlbmVyYXRlZDogJHtkdWJiZWRBdWRpb1BhdGhfTVAzfWApO1xyXG5cclxuICAgIC8vIFN0ZXAgNDogU3luYyBBZGp1c3RtZW50IChUaW1lLVN0cmV0Y2ggVFRTIEF1ZGlvIHRvIE1hdGNoIE9yaWdpbmFsIER1cmF0aW9uKVxyXG4gICAgY29uc29sZS5sb2coYFske3ZpZGVvSWR9XSBBZGp1c3RpbmcgVFRTIEF1ZGlvIER1cmF0aW9uIHRvIE1hdGNoIE9yaWdpbmFsLi4uYCk7XHJcbiAgICBhd2FpdCBhZGp1c3RBdWRpb0R1cmF0aW9uV2l0aEZGbXBlZyhhdWRpb1BhdGgsIGR1YmJlZEF1ZGlvUGF0aF9NUDMsIGR1YmJlZEF1ZGlvUGF0aEFkanVzdGVkX01QMyk7IC8vIFBhc3Mgb3JpZ2luYWwsIHJhdyBUVFMsIGFuZCB0YXJnZXQgYWRqdXN0ZWQgcGF0aHNcclxuICAgIGNvbnNvbGUubG9nKGBbJHt2aWRlb0lkfV0gVFRTIEF1ZGlvIER1cmF0aW9uIEFkanVzdGVkOiAke2R1YmJlZEF1ZGlvUGF0aEFkanVzdGVkX01QM31gKTtcclxuXHJcbiAgICAvLyAtLS0gUEhBU0UgMzogTWVyZ2luZyBBdWRpbyB3aXRoIFZpZGVvIC0tLVxyXG4gICAgY29uc29sZS5sb2coYFske3ZpZGVvSWR9XSBTdGFydGluZyBQaGFzZSAzOiBNZXJnaW5nIEFkanVzdGVkIER1YmJlZCBBdWRpb2ApO1xyXG4gICAgY29uc3Qgb3V0cHV0UGF0aCA9IHBhdGguam9pbih0ZW1wRGlyLCBgJHt2aWRlb0lkfV9kdWJiZWQubXA0YCk7XHJcblxyXG4gICAgLy8gVXNlIGEgUHJvbWlzZSB0byBoYW5kbGUgdGhlIEZGbXBlZyBtZXJnZSBwcm9jZXNzIGNvcnJlY3RseSB3aXRoIGV4cGxpY2l0IG1hcHBpbmdcclxuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgY29uc3QgZmZtcGVnQ29tbWFuZCA9IGZmbXBlZyh2aWRlb1BhdGgpIC8vIElucHV0IHZpZGVvIGZpbGUgKGNvbnRhaW5zIG9yaWdpbmFsIGF1ZGlvKVxyXG4gICAgICAgIC5pbnB1dChkdWJiZWRBdWRpb1BhdGhBZGp1c3RlZF9NUDMpIC8vIElucHV0IGFkanVzdGVkIFRUUyBhdWRpbyBmaWxlICgubXAzKVxyXG4gICAgICAgIC5vdXRwdXRPcHRpb25zKFtcclxuICAgICAgICAgICctbWFwJywgJzA6dicsICAgIC8vIEV4cGxpY2l0bHkgbWFwIHRoZSB2aWRlbyBzdHJlYW0gZnJvbSB0aGUgZmlyc3QgaW5wdXQgKHZpZGVvUGF0aClcclxuICAgICAgICAgICctbWFwJywgJzE6YScsICAgIC8vIEV4cGxpY2l0bHkgbWFwIHRoZSBhdWRpbyBzdHJlYW0gZnJvbSB0aGUgc2Vjb25kIGlucHV0IChkdWJiZWRBdWRpb1BhdGhBZGp1c3RlZF9NUDMpXHJcbiAgICAgICAgICAnLWM6dicsICdjb3B5JywgICAvLyBDb3B5IHZpZGVvIHN0cmVhbSB3aXRob3V0IHJlLWVuY29kaW5nIChmYXN0ZXIpXHJcbiAgICAgICAgICAnLWM6YScsICdhYWMnLCAgICAvLyBFbmNvZGUgdGhlIG1hcHBlZCBhdWRpbyBzdHJlYW0gdG8gQUFDXHJcbiAgICAgICAgICAnLXN0cmljdCcsICdleHBlcmltZW50YWwnLCAvLyBNaWdodCBiZSBuZWVkZWQgZm9yIGNlcnRhaW4gQUFDIGVuY29kaW5nc1xyXG4gICAgICAgIF0pXHJcbiAgICAgICAgLm91dHB1dChvdXRwdXRQYXRoKTtcclxuXHJcbiAgICAgIGZmbXBlZ0NvbW1hbmRcclxuICAgICAgICAub24oJ3N0YXJ0JywgKGNtZCkgPT4ge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYEZGbXBlZyBtZXJnZSBjb21tYW5kIHN0YXJ0ZWQ6ICR7Y21kfWApO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdwcm9ncmVzcycsIChwcm9ncmVzcykgPT4ge1xyXG4gICAgICAgICAgLy8gT3B0aW9uYWw6IExvZyBwcm9ncmVzc1xyXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coYEZGbXBlZyBtZXJnZSBwcm9ncmVzczogZnJhbWU9JHtwcm9ncmVzcy5mcmFtZX0sIHRpbWVtYXJrPSR7cHJvZ3Jlc3MudGltZW1hcmt9LCBmcHM9JHtwcm9ncmVzcy5mcHN9YCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ2VuZCcsIChzdGRvdXQsIHN0ZGVycikgPT4ge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYFske3ZpZGVvSWR9XSBNZXJnaW5nIGNvbXBsZXRlZDogJHtvdXRwdXRQYXRofWApO1xyXG4gICAgICAgICAgaWYgKHN0ZGVycikge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihgWyR7dmlkZW9JZH1dIEZGbXBlZyBtZXJnZSBzdGRlcnIgKHdhcm5pbmdzKTogJHtzdGRlcnJ9YCk7IC8vIExvZyB3YXJuaW5nc1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gQ2xlYW4gdXAgaW50ZXJtZWRpYXRlIGZpbGVzIGFmdGVyIHN1Y2Nlc3NmdWwgbWVyZ2VcclxuICAgICAgICAgIGZzLnVubGluayhkdWJiZWRBdWRpb1BhdGhfTVAzLCAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICBpZiAoZXJyKSBjb25zb2xlLmVycm9yKGBbJHt2aWRlb0lkfV0gRXJyb3IgZGVsZXRpbmcgcmF3IFRUUyBmaWxlOmAsIGVycik7XHJcbiAgICAgICAgICAgICBlbHNlIGNvbnNvbGUubG9nKGBbJHt2aWRlb0lkfV0gRGVsZXRlZCByYXcgVFRTIGZpbGU6ICR7ZHViYmVkQXVkaW9QYXRoX01QM31gKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcmVzb2x2ZSgpOyAvLyBSZXNvbHZlIHRoZSBwcm9taXNlIG9uIHN1Y2Nlc3NmdWwgZW5kXHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ2Vycm9yJywgKGVyciwgc3Rkb3V0LCBzdGRlcnIpID0+IHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFske3ZpZGVvSWR9XSBGRm1wZWcgRVJST1IgZHVyaW5nIG1lcmdlOmAsIGVyci5tZXNzYWdlKTtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFske3ZpZGVvSWR9XSBGRm1wZWcgbWVyZ2Ugc3Rkb3V0OmAsIHN0ZG91dCk7IC8vIExvZyBzdGRvdXQgaW4gY2FzZSBvZiBlcnJvclxyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgWyR7dmlkZW9JZH1dIEZGbXBlZyBtZXJnZSBzdGRlcnI6YCwgc3RkZXJyKTsgLy8gTG9nIHN0ZGVyciBpbiBjYXNlIG9mIGVycm9yXHJcbiAgICAgICAgICByZWplY3QoZXJyKTsgLy8gUmVqZWN0IHRoZSBwcm9taXNlIG9uIGVycm9yXHJcbiAgICAgICAgfSlcclxuICAgICAgICAucnVuKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBVcGRhdGUgbWV0YWRhdGEgc3RhdHVzXHJcbiAgICBjb25zdCBtZXRhZGF0YSA9IEpTT04ucGFyc2UoYXdhaXQgZnMucHJvbWlzZXMucmVhZEZpbGUobWV0YWRhdGFQYXRoLCAndXRmOCcpKTtcclxuICAgIG1ldGFkYXRhLnN0YXR1cyA9ICdjb21wbGV0ZWQnO1xyXG4gICAgbWV0YWRhdGEub3V0cHV0UGF0aCA9IG91dHB1dFBhdGg7XHJcbiAgICBtZXRhZGF0YS5wcm9jZXNzZWRUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcbiAgICBhd2FpdCBmcy5wcm9taXNlcy53cml0ZUZpbGUobWV0YWRhdGFQYXRoLCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xyXG5cclxuICAgIHJlcy5zdGF0dXMoMjAwKS5qc29uKHsgbWVzc2FnZTogJ1Byb2Nlc3Npbmcgc3VjY2Vzc2Z1bCcsIHZpZGVvSWQsIHN0YXR1czogJ2NvbXBsZXRlZCcgfSk7XHJcblxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKGBbJHt2aWRlb0lkfV0gUHJvY2Vzc2luZyBFcnJvcjpgLCBlcnJvcik7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gSlNPTi5wYXJzZShhd2FpdCBmcy5wcm9taXNlcy5yZWFkRmlsZShtZXRhZGF0YVBhdGgsICd1dGY4JykpO1xyXG4gICAgICAgIG1ldGFkYXRhLnN0YXR1cyA9ICdmYWlsZWQnO1xyXG4gICAgICAgIG1ldGFkYXRhLmVycm9yID0gZXJyb3IubWVzc2FnZTtcclxuICAgICAgICBhd2FpdCBmcy5wcm9taXNlcy53cml0ZUZpbGUobWV0YWRhdGFQYXRoLCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xyXG4gICAgfSBjYXRjaCAobWV0YUVycikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFske3ZpZGVvSWR9XSBGYWlsZWQgdG8gdXBkYXRlIG1ldGFkYXRhIG9uIGVycm9yOmAsIG1ldGFFcnIpO1xyXG4gICAgfVxyXG4gICAgcmVzLnN0YXR1cyg1MDApLmpzb24oeyBtZXNzYWdlOiAnUHJvY2Vzc2luZyBmYWlsZWQnLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9KTtcclxuICB9XHJcbn1cclxuXHJcbi8vIC0tLSBBU1IgRnVuY3Rpb24gdXNpbmcgQXNzZW1ibHlBSSAoRlJFRSBUaWVyIEF2YWlsYWJsZSkgLS0tXHJcbmFzeW5jIGZ1bmN0aW9uIHRyYW5zY3JpYmVBdWRpb1dpdGhBc3NlbWJseUFJKGF1ZGlvRmlsZVBhdGgsIHNvdXJjZUxhbmcpIHtcclxuICBjb25zdCBBU1NFTUJMWUFJX0FQSV9LRVkgPSBwcm9jZXNzLmVudi5BU1NFTUJMWUFJX0FQSV9LRVk7XHJcbiAgaWYgKCFBU1NFTUJMWUFJX0FQSV9LRVkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkFTU0VNQkxZQUlfQVBJX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyByZXF1aXJlZCBmb3IgQXNzZW1ibHlBSSBBU1IuXCIpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZW5kcG9pbnQgPSAnaHR0cHM6Ly9hcGkuYXNzZW1ibHlhaS5jb20vdjInOyAvLyBDb3JyZWN0ZWQgZW5kcG9pbnQgKHJlbW92ZWQgdHJhaWxpbmcgc3BhY2VzKVxyXG5cclxuICAvLyBTdGVwIDE6IFVwbG9hZCB0aGUgYXVkaW8gZmlsZVxyXG4gIGNvbnNvbGUubG9nKFwiVXBsb2FkaW5nIGF1ZGlvIHRvIEFzc2VtYmx5QUkuLi5cIik7XHJcbiAgY29uc3QgYXVkaW9EYXRhID0gZnMucmVhZEZpbGVTeW5jKGF1ZGlvRmlsZVBhdGgpO1xyXG4gIGNvbnN0IHVwbG9hZFJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7ZW5kcG9pbnR9L3VwbG9hZGAsIHtcclxuICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgYm9keTogYXVkaW9EYXRhLFxyXG4gICAgaGVhZGVyczoge1xyXG4gICAgICAnQXV0aG9yaXphdGlvbic6IEFTU0VNQkxZQUlfQVBJX0tFWSxcclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIGlmICghdXBsb2FkUmVzcG9uc2Uub2spIHtcclxuICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHVwbG9hZFJlc3BvbnNlLnRleHQoKTtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJBc3NlbWJseUFJIFVwbG9hZCBFcnJvcjpcIiwgdXBsb2FkUmVzcG9uc2Uuc3RhdHVzLCBlcnJvclRleHQpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBBc3NlbWJseUFJIFVwbG9hZCBmYWlsZWQ6ICR7dXBsb2FkUmVzcG9uc2Uuc3RhdHVzfSAtICR7ZXJyb3JUZXh0fWApO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgdXBsb2FkRGF0YSA9IGF3YWl0IHVwbG9hZFJlc3BvbnNlLmpzb24oKTtcclxuICBjb25zdCBhdWRpb1VybCA9IHVwbG9hZERhdGEudXBsb2FkX3VybDtcclxuICBjb25zb2xlLmxvZyhcIkF1ZGlvIHVwbG9hZGVkIHN1Y2Nlc3NmdWxseS4gVVJMOlwiLCBhdWRpb1VybCk7XHJcblxyXG4gIC8vIFN0ZXAgMjogUmVxdWVzdCB0cmFuc2NyaXB0aW9uXHJcbiAgY29uc29sZS5sb2coXCJSZXF1ZXN0aW5nIHRyYW5zY3JpcHRpb24gZnJvbSBBc3NlbWJseUFJLi4uXCIpO1xyXG4gIGNvbnN0IHRyYW5zY3JpYmVSZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke2VuZHBvaW50fS90cmFuc2NyaXB0YCwge1xyXG4gICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgIGF1ZGlvX3VybDogYXVkaW9VcmwsXHJcbiAgICAgIC8vIGxhbmd1YWdlX2NvZGU6IHNvdXJjZUxhbmcsIC8vIE9wdGlvbmFsOiBTcGVjaWZ5IGxhbmd1YWdlIGlmIG5lZWRlZCwgQXNzZW1ibHlBSSBvZnRlbiBhdXRvLWRldGVjdHNcclxuICAgIH0pLFxyXG4gICAgaGVhZGVyczoge1xyXG4gICAgICAnQXV0aG9yaXphdGlvbic6IEFTU0VNQkxZQUlfQVBJX0tFWSxcclxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIGlmICghdHJhbnNjcmliZVJlc3BvbnNlLm9rKSB7XHJcbiAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCB0cmFuc2NyaWJlUmVzcG9uc2UudGV4dCgpO1xyXG4gICAgY29uc29sZS5lcnJvcihcIkFzc2VtYmx5QUkgVHJhbnNjcmliZSBSZXF1ZXN0IEVycm9yOlwiLCB0cmFuc2NyaWJlUmVzcG9uc2Uuc3RhdHVzLCBlcnJvclRleHQpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBBc3NlbWJseUFJIFRyYW5zY3JpYmUgUmVxdWVzdCBmYWlsZWQ6ICR7dHJhbnNjcmliZVJlc3BvbnNlLnN0YXR1c30gLSAke2Vycm9yVGV4dH1gKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHRyYW5zY3JpYmVEYXRhID0gYXdhaXQgdHJhbnNjcmliZVJlc3BvbnNlLmpzb24oKTtcclxuICBjb25zdCB0cmFuc2NyaXB0SWQgPSB0cmFuc2NyaWJlRGF0YS5pZDtcclxuICBjb25zb2xlLmxvZyhcIlRyYW5zY3JpcHRpb24gcmVxdWVzdCBzdWJtaXR0ZWQuIElEOlwiLCB0cmFuc2NyaXB0SWQpO1xyXG5cclxuICAvLyBTdGVwIDM6IFBvbGwgZm9yIGNvbXBsZXRpb25cclxuICBjb25zb2xlLmxvZyhcIlBvbGxpbmcgZm9yIHRyYW5zY3JpcHRpb24gY29tcGxldGlvbi4uLlwiKTtcclxuICBsZXQgcG9sbGluZ0VuZHBvaW50ID0gYCR7ZW5kcG9pbnR9L3RyYW5zY3JpcHQvJHt0cmFuc2NyaXB0SWR9YDtcclxuICBsZXQgcmVzdWx0O1xyXG4gIHdoaWxlICh0cnVlKSB7IC8vIFNpbXBsZSBwb2xsaW5nIGxvb3BcclxuICAgIGNvbnN0IHBvbGxSZXNwb25zZSA9IGF3YWl0IGZldGNoKHBvbGxpbmdFbmRwb2ludCwge1xyXG4gICAgICBoZWFkZXJzOiB7ICdBdXRob3JpemF0aW9uJzogQVNTRU1CTFlBSV9BUElfS0VZIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoIXBvbGxSZXNwb25zZS5vaykge1xyXG4gICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCBwb2xsUmVzcG9uc2UudGV4dCgpO1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiQXNzZW1ibHlBSSBQb2xsaW5nIEVycm9yOlwiLCBwb2xsUmVzcG9uc2Uuc3RhdHVzLCBlcnJvclRleHQpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFzc2VtYmx5QUkgUG9sbGluZyBmYWlsZWQ6ICR7cG9sbFJlc3BvbnNlLnN0YXR1c30gLSAke2Vycm9yVGV4dH1gKTtcclxuICAgIH1cclxuXHJcbiAgICByZXN1bHQgPSBhd2FpdCBwb2xsUmVzcG9uc2UuanNvbigpO1xyXG4gICAgY29uc3Qgc3RhdHVzID0gcmVzdWx0LnN0YXR1cztcclxuXHJcbiAgICBpZiAoc3RhdHVzID09PSAnY29tcGxldGVkJykge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIkFzc2VtYmx5QUkgdHJhbnNjcmlwdGlvbiBjb21wbGV0ZWQuXCIpO1xyXG4gICAgICBicmVhazsgLy8gRXhpdCB0aGUgbG9vcFxyXG4gICAgfSBlbHNlIGlmIChzdGF0dXMgPT09ICdlcnJvcicpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkFzc2VtYmx5QUkgdHJhbnNjcmlwdGlvbiBmYWlsZWQ6XCIsIHJlc3VsdC5lcnJvcik7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXNzZW1ibHlBSSBUcmFuc2NyaXB0aW9uIEVycm9yOiAke3Jlc3VsdC5lcnJvcn1gKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDAwKSk7IC8vIFdhaXQgMyBzZWNvbmRzIGJlZm9yZSBuZXh0IHBvbGxcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFJldHVybiB0aGUgdHJhbnNjcmliZWQgdGV4dFxyXG4gIGlmIChyZXN1bHQudGV4dCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiUmF3IEFzc2VtYmx5QUkgUmVzdWx0OlwiLCB7IHRleHQ6IHJlc3VsdC50ZXh0LCBjb25maWRlbmNlOiByZXN1bHQuY29uZmlkZW5jZSB9KTtcclxuICAgICAgcmV0dXJuIHJlc3VsdC50ZXh0LnRyaW0oKTtcclxuICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiVW5leHBlY3RlZCBBc3NlbWJseUFJIHJlc3BvbnNlIGZvcm1hdDpcIiwgcmVzdWx0KTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXNzZW1ibHlBSSByZXR1cm5lZCB1bmV4cGVjdGVkIGRhdGEgZm9ybWF0LlwiKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIC0tLSBUcmFuc2xhdGlvbiBGdW5jdGlvbiB1c2luZyBHb29nbGUgR2VtaW5pIEFQSSAoMi41IEZsYXNoKSAtIER1YmJpbmcgRm9jdXNlZCAtLS1cclxuYXN5bmMgZnVuY3Rpb24gdHJhbnNsYXRlV2l0aEdlbWluaSh0ZXh0LCBzb3VyY2VMYW5nLCB0YXJnZXRMYW5nKSB7XHJcbiAgY29uc3QgR0VNSU5JX0FQSV9LRVkgPSBwcm9jZXNzLmVudi5HRU1JTklfQVBJX0tFWTtcclxuICBpZiAoIUdFTUlOSV9BUElfS0VZKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJHRU1JTklfQVBJX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyByZXF1aXJlZCBmb3IgR2VtaW5pIFRyYW5zbGF0aW9uLlwiKTtcclxuICB9XHJcblxyXG4gIC8vIEluaXRpYWxpemUgdGhlIEdvb2dsZSBBSSBTREsgY2xpZW50XHJcbiAgY29uc3QgZ2VuQUkgPSBuZXcgR29vZ2xlR2VuZXJhdGl2ZUFJKEdFTUlOSV9BUElfS0VZKTtcclxuICAvLyBVc2UgdGhlIGF2YWlsYWJsZSBtb2RlbDogZ2VtaW5pLTIuNS1mbGFzaCAob3IgZ2VtaW5pLTIuNS1wcm8sIGdlbWluaS1mbGFzaC1sYXRlc3QsIGdlbWluaS1wcm8tbGF0ZXN0KVxyXG4gIC8vIEJhc2VkIG9uIHRoZSBtb2RlbCBsaXN0aW5nIHlvdSBwcm92aWRlZCwgZ2VtaW5pLTIuNS1mbGFzaCBpcyBhdmFpbGFibGUgYW5kIHN1cHBvcnRzIGdlbmVyYXRlQ29udGVudC5cclxuICBjb25zdCBtb2RlbCA9IGdlbkFJLmdldEdlbmVyYXRpdmVNb2RlbCh7IG1vZGVsOiBcImdlbWluaS0yLjUtZmxhc2hcIiB9KTsgLy8gVXBkYXRlZCBtb2RlbCBuYW1lXHJcblxyXG4gIC8vIENyYWZ0IHRoZSBwcm9tcHQgZm9yIHRyYW5zbGF0aW9uLCBmb2N1c2VkIG9uIGR1YmJpbmdcclxuICAvLyBBc2sgR2VtaW5pIHRvIHRyYW5zbGF0ZSB3aGlsZSBrZWVwaW5nIHRoZSBzZW50ZW5jZSBzdHJ1Y3R1cmUgYW5kIGFwcHJveGltYXRlIHdvcmQgY291bnQgc2ltaWxhclxyXG4gIC8vIHRvIHRoZSBvcmlnaW5hbCB0ZXh0IHRvIGhlbHAgd2l0aCBhdWRpbyB0aW1pbmcgZHVyaW5nIGR1YmJpbmcuXHJcbiAgY29uc3QgcHJvbXB0ID0gYFxyXG5Zb3UgYXJlIGEgdHJhbnNsYXRvciB0YXNrZWQgd2l0aCBwcmVwYXJpbmcgdGV4dCBmb3IgYXVkaW8gZHViYmluZy4gWW91ciBnb2FsIGlzIHRvIHRyYW5zbGF0ZSB0aGUgcHJvdmlkZWQgJHtzb3VyY2VMYW5nfSB0ZXh0IGludG8gJHt0YXJnZXRMYW5nfSB3aGlsZSBwcmVzZXJ2aW5nIHRoZSBvcmlnaW5hbCBzZW50ZW5jZSBzdHJ1Y3R1cmUgYW5kIHJoeXRobSBhcyBjbG9zZWx5IGFzIHBvc3NpYmxlLiBUaGlzIGlzIGNydWNpYWwgZm9yIGFsaWduaW5nIHRoZSB0cmFuc2xhdGVkIGF1ZGlvIHdpdGggdGhlIG9yaWdpbmFsIHZpZGVvJ3MgdGltaW5nLlxyXG5cclxuUGxlYXNlIGZvbGxvdyB0aGVzZSBndWlkZWxpbmVzOlxyXG4xLiAgKipUcmFuc2xhdGUgYWNjdXJhdGVseToqKiBFbnN1cmUgdGhlIG1lYW5pbmcgb2YgdGhlIG9yaWdpbmFsIHRleHQgaXMgY29ycmVjdGx5IGNvbnZleWVkLlxyXG4yLiAgKipQcmVzZXJ2ZSBTdHJ1Y3R1cmU6KiogS2VlcCBzZW50ZW5jZXMgYnJva2VuIHVwIGluIGEgc2ltaWxhciB3YXkuIElmIHRoZSBvcmlnaW5hbCBoYXMgMyBzZW50ZW5jZXMsIGFpbSBmb3IgMyB0cmFuc2xhdGVkIHNlbnRlbmNlcy5cclxuMy4gICoqTWF0Y2ggUmh5dGhtL0FwcHJveGltYXRlIExlbmd0aDoqKiBUcnkgdG8gdXNlIGEgc2ltaWxhciBudW1iZXIgb2Ygd29yZHMgYW5kIHN5bGxhYmxlcyB3aGVyZSBwb3NzaWJsZS4gQXZvaWQgbWFraW5nIHNlbnRlbmNlcyBzaWduaWZpY2FudGx5IGxvbmdlciBvciBzaG9ydGVyIHRoYW4gdGhlIG9yaWdpbmFsLiBUaGlzIGhlbHBzIHRoZSBnZW5lcmF0ZWQgc3BlZWNoIG1hdGNoIHRoZSBvcmlnaW5hbCBhdWRpbydzIGR1cmF0aW9uLlxyXG40LiAgKipPdXRwdXQgT25seSBUcmFuc2xhdGlvbjoqKiBQcm92aWRlIG9ubHkgdGhlIHRyYW5zbGF0ZWQgdGV4dCwgbm90aGluZyBlbHNlLlxyXG5cclxuT3JpZ2luYWwgJHtzb3VyY2VMYW5nfSB0ZXh0OlxyXG4ke3RleHR9XHJcbmA7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZyhgQ2FsbGluZyBHZW1pbmkgQVBJIGZvciBkdWJiaW5nLWZvY3VzZWQgdHJhbnNsYXRpb24gKE1vZGVsOiAke21vZGVsLm1vZGVsfSkgZnJvbSAke3NvdXJjZUxhbmd9IHRvICR7dGFyZ2V0TGFuZ30uLi5gKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1vZGVsLmdlbmVyYXRlQ29udGVudChwcm9tcHQpO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXN1bHQucmVzcG9uc2U7XHJcbiAgICBjb25zdCB0cmFuc2xhdGVkVGV4dCA9IHJlc3BvbnNlLnRleHQoKTtcclxuXHJcbiAgICBpZiAoIXRyYW5zbGF0ZWRUZXh0KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VtaW5pIEFQSSByZXR1cm5lZCBlbXB0eSB0cmFuc2xhdGlvbiB0ZXh0LlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIlJhdyBHZW1pbmkgVHJhbnNsYXRpb24gUmVzcG9uc2U6XCIsIHJlc3BvbnNlKTtcclxuICAgIGNvbnNvbGUubG9nKFwiRmluYWwgdHJhbnNsYXRlZCB0ZXh0IGZvciBUVFM6XCIsIHRyYW5zbGF0ZWRUZXh0LnRyaW0oKSk7XHJcbiAgICByZXR1cm4gdHJhbnNsYXRlZFRleHQudHJpbSgpOyAvLyBSZXR1cm4gdGhlIHRyYW5zbGF0ZWQgdGV4dFxyXG5cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkdlbWluaSBUcmFuc2xhdGlvbiBFcnJvcjpcIiwgZXJyb3IpO1xyXG4gICAgLy8gQ2hlY2sgZm9yIHNwZWNpZmljIGVycm9yIGRldGFpbHMgZnJvbSB0aGUgQVBJXHJcbiAgICBpZiAoZXJyb3IubWVzc2FnZSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJHZW1pbmkgRXJyb3IgTWVzc2FnZTpcIiwgZXJyb3IubWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn1cclxuXHJcbi8vIC0tLSBUVFMgRnVuY3Rpb246IEdlbmVyYXRlIFNwZWVjaCB1c2luZyBFbGV2ZW5MYWJzIEFQSSAoUHJpbWFyeSkgb3IgR29vZ2xlIFRyYW5zbGF0ZSBUVFMgKEZhbGxiYWNrKSAtLS1cclxuLy8gVXNlcyB0aGUgRWxldmVuTGFicyBBUEkgYXMgcHJpbWFyeSwgYW5kIGZhbGxzIGJhY2sgdG8gYW4gdW5vZmZpY2lhbCBHb29nbGUgVHJhbnNsYXRlIFRUUyBBUEkgaWYgbm8gRWxldmVuTGFicyBrZXkgaXMgZm91bmQuXHJcbi8vIE5vdGU6IEVsZXZlbkxhYnMgcmVzdHJpY3RzIGFjY2VzcyBmcm9tIGNlcnRhaW4gY291bnRyaWVzIChlLmcuLCBSdXNzaWEsIElyYW4sIE5vcnRoIEtvcmVhLCBCZWxhcnVzLCBTeXJpYSwgQ3ViYSwgQ3JpbWVhLCBEb25ldHNrLCBMdWhhbnNrKS5cclxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVUVFNXaXRoRWxldmVuTGFicyh0ZXh0LCBvdXRwdXRQYXRoLCB0YXJnZXRMYW5nKSB7XHJcbiAgY29uc3QgRUxFVkVOTEFCU19BUElfS0VZID0gcHJvY2Vzcy5lbnYuRUxFVkVOTEFCU19BUElfS0VZO1xyXG5cclxuICAvLyBDaGVjayBpZiBFbGV2ZW5MYWJzIEFQSSBrZXkgZXhpc3RzXHJcbiAgaWYgKEVMRVZFTkxBQlNfQVBJX0tFWSkge1xyXG4gICAgY29uc29sZS5sb2coXCJVc2luZyBFbGV2ZW5MYWJzIEFQSSBmb3IgVFRTLlwiKTtcclxuICAgIGF3YWl0IGdlbmVyYXRlVFRTV2l0aEVsZXZlbkxhYnNBUEkodGV4dCwgb3V0cHV0UGF0aCwgdGFyZ2V0TGFuZywgRUxFVkVOTEFCU19BUElfS0VZKTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc29sZS5sb2coXCJFTEVWRU5MQUJTX0FQSV9LRVkgbm90IGZvdW5kLiBGYWxsaW5nIGJhY2sgdG8gdW5vZmZpY2lhbCBHb29nbGUgVHJhbnNsYXRlIFRUUy5cIik7XHJcbiAgICBhd2FpdCBnZW5lcmF0ZVRUU1dpdGhHb29nbGVUVFModGV4dCwgb3V0cHV0UGF0aCwgdGFyZ2V0TGFuZyk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyAtLS0gUHJpbWFyeSBUVFMgRnVuY3Rpb246IEdlbmVyYXRlIFNwZWVjaCB1c2luZyBFbGV2ZW5MYWJzIEFQSSAtLS1cclxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVUVFNXaXRoRWxldmVuTGFic0FQSSh0ZXh0LCBvdXRwdXRQYXRoLCB0YXJnZXRMYW5nLCBhcGlLZXkpIHtcclxuICAvLyBFbGV2ZW5MYWJzIHZvaWNlIElEIG1hcHBpbmcgLSBVcGRhdGVkIHdpdGggdGhlIGNvcnJlY3QgSGluZGkgdm9pY2UgSURcclxuICBjb25zdCB2b2ljZUlkTWFwID0ge1xyXG4gICAgICAnaGknOiAnalVqUmJoWldvTUs0YURjaVczNlYnLCAvLyBDb3JyZWN0ZWQgSGluZGkgdm9pY2UgSURcclxuICAgICAgJ2VuJzogJzIxbTAwVGNtNFRsdkRxOGlrV0FNJywgLy8gRXhhbXBsZSBFbmdsaXNoIHZvaWNlIElEIChyZXBsYWNlIGlmIG5lZWRlZClcclxuICAgICAgJ2VzJzogJ0VYQVZJVFF1NHZyNHhuU0R4TWFMJywgLy8gRXhhbXBsZSBTcGFuaXNoIHZvaWNlIElEIChyZXBsYWNlIGlmIG5lZWRlZClcclxuICAgICAgLy8gQWRkIG1vcmUgbWFwcGluZ3MgYXMgbmVlZGVkXHJcbiAgfTtcclxuXHJcbiAgLy8gU2VsZWN0IHZvaWNlIElEIGJhc2VkIG9uIHRhcmdldCBsYW5ndWFnZSwgZGVmYXVsdCB0byBFbmdsaXNoIGlmIG5vdCBmb3VuZFxyXG4gIGNvbnN0IHZvaWNlSWQgPSB2b2ljZUlkTWFwW3RhcmdldExhbmddIHx8IHZvaWNlSWRNYXBbJ2VuJ107XHJcbiAgY29uc29sZS5sb2coYFVzaW5nIEVsZXZlbkxhYnMgdm9pY2UgSUQ6ICR7dm9pY2VJZH0gZm9yIHRhcmdldCBsYW5ndWFnZTogJHt0YXJnZXRMYW5nfWApO1xyXG5cclxuICAvLyBEZWZpbmUgdGhlIG91dHB1dCBmb3JtYXQgLSBVc2luZyBNUDMgYXMgV0FWIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIEFQSVxyXG4gIC8vIE9wdGlvbnMgaW5jbHVkZTogbXAzXzIyMDUwXzMyLCBtcDNfMjQwMDBfNDgsIG1wM180NDEwMF8zMiwgbXAzXzQ0MTAwXzY0LCBldGMuXHJcbiAgY29uc3Qgb3V0cHV0Rm9ybWF0ID0gJ21wM18yMjA1MF8zMic7IC8vIFVzaW5nIE1QMyBmb3JtYXRcclxuICBjb25zdCB1cmwgPSBgaHR0cHM6Ly9hcGkuZWxldmVubGFicy5pby92MS90ZXh0LXRvLXNwZWVjaC8ke3ZvaWNlSWQudHJpbSgpfT9vcHRpbWl6ZV9zdHJlYW1pbmdfbGF0ZW5jeT0wJm91dHB1dF9mb3JtYXQ9JHtvdXRwdXRGb3JtYXR9YDsgLy8gQ29ycmVjdGVkIFVSTCAocmVtb3ZlZCB0cmFpbGluZyBzcGFjZXMpXHJcblxyXG4gIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xyXG4gICAgdGV4dDogdGV4dCxcclxuICAgIC8vIFlvdSBjYW4gYWRkIG90aGVyIG9wdGlvbnMgaGVyZSBpZiBuZWVkZWQsIGxpa2Ugdm9pY2Vfc2V0dGluZ3MsIG1vZGVsX2lkLCBldGMuXHJcbiAgICAvLyBGb3IgZXhhbXBsZSwgdG8gYWRqdXN0IHN0YWJpbGl0eSBvciBzaW1pbGFyaXR5X2Jvb3N0OlxyXG4gICAgLy8gdm9pY2Vfc2V0dGluZ3M6IHtcclxuICAgIC8vICAgc3RhYmlsaXR5OiAwLjc1LFxyXG4gICAgLy8gICBzaW1pbGFyaXR5X2Jvb3N0OiAwLjc1XHJcbiAgICAvLyB9XHJcbiAgfTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKGBDYWxsaW5nIEVsZXZlbkxhYnMgVFRTIEFQSSBmb3IgdGV4dDogXCIke3RleHQuc3Vic3RyaW5nKDAsIDMwKX0uLi5cIiB1c2luZyB2b2ljZTogJHt2b2ljZUlkfSBhbmQgZm9ybWF0OiAke291dHB1dEZvcm1hdH1gKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgJ3hpLWFwaS1rZXknOiBhcGlLZXksIC8vIFVzZSB0aGUgcGFzc2VkIEFQSSBrZXlcclxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgIC8vICdhY2NlcHQnOiAnYXVkaW8vbXBlZycsIC8vIE9wdGlvbmFsOiBzcGVjaWZ5IGV4cGVjdGVkIGZvcm1hdCBpZiBkaWZmZXJlbnQgZnJvbSBvdXRwdXRfZm9ybWF0IHBhcmFtZXRlclxyXG4gICAgICB9LFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSksXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVsZXZlbkxhYnMgVFRTIEFQSSBFcnJvcjpcIiwgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS5zdGF0dXNUZXh0LCBlcnJvclRleHQpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVsZXZlbkxhYnMgVFRTIEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0gLSAke2Vycm9yVGV4dH1gKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZWFkIHRoZSBhdWRpbyBkYXRhIGZyb20gdGhlIHJlc3BvbnNlIGJvZHkgKGl0J3MgYSBzdHJlYW0pXHJcbiAgICBjb25zdCBhdWRpb0J1ZmZlciA9IEJ1ZmZlci5mcm9tKGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpO1xyXG5cclxuICAgIC8vIFdyaXRlIHRoZSBhdWRpbyBidWZmZXIgdG8gdGhlIHNwZWNpZmllZCBvdXRwdXQgZmlsZSBwYXRoXHJcbiAgICAvLyBUaGUgb3V0cHV0IHBhdGggd2lsbCBub3cgYmUgYW4gLm1wMyBmaWxlLCB3aGljaCBpcyBmaW5lIGZvciBGRm1wZWcgbWVyZ2luZ1xyXG4gICAgYXdhaXQgZnMucHJvbWlzZXMud3JpdGVGaWxlKG91dHB1dFBhdGgsIGF1ZGlvQnVmZmVyKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhgRWxldmVuTGFicyBUVFMgYXVkaW8gc2F2ZWQgdG86ICR7b3V0cHV0UGF0aH1gKTtcclxuXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoYEVsZXZlbkxhYnMgVFRTIEFQSSBFcnJvciBpbiBnZW5lcmF0ZVRUU1dpdGhFbGV2ZW5MYWJzQVBJOmAsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufVxyXG5cclxuLy8gLS0tIEZhbGxiYWNrIFRUUyBGdW5jdGlvbjogR2VuZXJhdGUgU3BlZWNoIHVzaW5nIFVub2ZmaWNpYWwgR29vZ2xlIFRyYW5zbGF0ZSBUVFMgQVBJIChIYW5kbGVzIExvbmcgVGV4dCkgLS0tXHJcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlVFRTV2l0aEdvb2dsZVRUUyh0ZXh0LCBvdXRwdXRQYXRoLCB0YXJnZXRMYW5nKSB7XHJcbiAgICBjb25zdCB0cmFuc2xhdGUgPSByZXF1aXJlKCdnb29nbGUtdHRzLWFwaScpOyAvLyBJbXBvcnQgdGhlIGxpYnJhcnlcclxuXHJcbiAgICBjb25zdCBsYW5nID0gdGFyZ2V0TGFuZztcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBbR29vZ2xlVFRTXSBTcGxpdHRpbmcgYW5kIHByb2Nlc3NpbmcgbG9uZyB0ZXh0IGZvciBUVFMgKGxhbmd1YWdlOiAke2xhbmd9KWApO1xyXG4gICAgICAgIC8vIFVzZSBnZXRBbGxBdWRpb1VybHMgdG8gaGFuZGxlIGxvbmcgdGV4dC4gVGhpcyByZXR1cm5zIGFuIGFycmF5IG9mIFVSTHMgZm9yIGNodW5rcy5cclxuICAgICAgICAvLyBJdCBhdXRvbWF0aWNhbGx5IHNwbGl0cyB0aGUgdGV4dCBiYXNlZCBvbiB0aGUgY2hhcmFjdGVyIGxpbWl0LlxyXG4gICAgICAgIGNvbnN0IGF1ZGlvVXJscyA9IHRyYW5zbGF0ZS5nZXRBbGxBdWRpb1VybHModGV4dCwge1xyXG4gICAgICAgICAgICBsYW5nOiBsYW5nLFxyXG4gICAgICAgICAgICBzbG93OiBmYWxzZSxcclxuICAgICAgICAgICAgaG9zdDogJ2h0dHBzOi8vdHJhbnNsYXRlLmdvb2dsZS5jb20nLFxyXG4gICAgICAgICAgICB0aW1lb3V0OiAxMDAwMCxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYFtHb29nbGVUVFNdIEdlbmVyYXRlZCAke2F1ZGlvVXJscy5sZW5ndGh9IGF1ZGlvIGNodW5rKHMpLmApO1xyXG5cclxuICAgICAgICAvLyBGZXRjaCBlYWNoIGF1ZGlvIGNodW5rIGFuZCBzdG9yZSB0aGUgYnVmZmVyc1xyXG4gICAgICAgIGNvbnN0IGF1ZGlvQnVmZmVycyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXVkaW9VcmxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNodW5rVXJsID0gYXVkaW9VcmxzW2ldLnVybDsgLy8gRXh0cmFjdCB0aGUgVVJMIGZyb20gdGhlIG9iamVjdFxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW0dvb2dsZVRUU10gRmV0Y2hpbmcgY2h1bmsgJHtpICsgMX0vJHthdWRpb1VybHMubGVuZ3RofSBmcm9tOiAke2NodW5rVXJsLnN1YnN0cmluZygwLCAxMDApfS4uLmApOyAvLyBMb2cgZmlyc3QgMTAwIGNoYXJzIG9mIFVSTFxyXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGNodW5rVXJsKTtcclxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHb29nbGUgVFRTIENodW5rICR7aSArIDF9IEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpO1xyXG4gICAgICAgICAgICBhdWRpb0J1ZmZlcnMucHVzaChidWZmZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29uY2F0ZW5hdGUgdGhlIGF1ZGlvIGJ1ZmZlcnMgdXNpbmcgRkZtcGVnXHJcbiAgICAgICAgY29uc29sZS5sb2coYFtHb29nbGVUVFNdIENvbmNhdGVuYXRpbmcgJHthdWRpb0J1ZmZlcnMubGVuZ3RofSBhdWRpbyBjaHVua3MgdXNpbmcgRkZtcGVnLi4uYCk7XHJcbiAgICAgICAgY29uc3QgdGVtcENvbmNhdERpciA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAndGVtcF91cGxvYWRzJywgJ3R0c19jaHVua3MnKTtcclxuICAgICAgICBmcy5ta2RpclN5bmModGVtcENvbmNhdERpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7IC8vIENyZWF0ZSBkaXJlY3RvcnkgaWYgaXQgZG9lc24ndCBleGlzdFxyXG5cclxuICAgICAgICAvLyBXcml0ZSBlYWNoIGNodW5rIGJ1ZmZlciB0byBhIHRlbXBvcmFyeSBmaWxlXHJcbiAgICAgICAgY29uc3QgdGVtcENodW5rRmlsZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF1ZGlvQnVmZmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjaHVua0ZpbGVOYW1lID0gYGNodW5rXyR7RGF0ZS5ub3coKX1fJHtpfS5tcDNgO1xyXG4gICAgICAgICAgICBjb25zdCBjaHVua0ZpbGVQYXRoID0gcGF0aC5qb2luKHRlbXBDb25jYXREaXIsIGNodW5rRmlsZU5hbWUpO1xyXG4gICAgICAgICAgICBhd2FpdCBmcy5wcm9taXNlcy53cml0ZUZpbGUoY2h1bmtGaWxlUGF0aCwgYXVkaW9CdWZmZXJzW2ldKTtcclxuICAgICAgICAgICAgdGVtcENodW5rRmlsZXMucHVzaChjaHVua0ZpbGVQYXRoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBmaWxlIGxpc3QgZm9yIEZGbXBlZydzIGNvbmNhdCBkZW11eGVyXHJcbiAgICAgICAgY29uc3QgZmlsZUxpc3RQYXRoID0gcGF0aC5qb2luKHRlbXBDb25jYXREaXIsIGBmaWxlX2xpc3RfJHtEYXRlLm5vdygpfS50eHRgKTtcclxuICAgICAgICBjb25zdCBmaWxlTGlzdENvbnRlbnQgPSB0ZW1wQ2h1bmtGaWxlcy5tYXAoZmlsZSA9PiBgZmlsZSAnJHtmaWxlfSdgKS5qb2luKCdcXG4nKTtcclxuICAgICAgICBhd2FpdCBmcy5wcm9taXNlcy53cml0ZUZpbGUoZmlsZUxpc3RQYXRoLCBmaWxlTGlzdENvbnRlbnQpO1xyXG5cclxuICAgICAgICAvLyBVc2UgRkZtcGVnIHRvIGNvbmNhdGVuYXRlIHRoZSBmaWxlc1xyXG4gICAgICAgIGNvbnN0IGZpbmFsT3V0cHV0UGF0aCA9IG91dHB1dFBhdGg7IC8vIFRoZSBmaW5hbCBvdXRwdXQgcGF0aFxyXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgZmZtcGVnKClcclxuICAgICAgICAgICAgICAgIC5pbnB1dChmaWxlTGlzdFBhdGgpXHJcbiAgICAgICAgICAgICAgICAuaW5wdXRPcHRpb25zKFsnLWYnLCAnY29uY2F0JywgJy1zYWZlJywgJzAnXSkgLy8gSW5wdXQgb3B0aW9ucyBmb3IgY29uY2F0IGRlbXV4ZXJcclxuICAgICAgICAgICAgICAgIC5vdXRwdXRPcHRpb25zKFsnLWMnLCAnY29weSddKSAvLyBDb3B5IHN0cmVhbXMgd2l0aG91dCByZS1lbmNvZGluZyBmb3Igc3BlZWRcclxuICAgICAgICAgICAgICAgIC5vdXRwdXQoZmluYWxPdXRwdXRQYXRoKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdzdGFydCcsIChjbWQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW0dvb2dsZVRUU10gRkZtcGVnIGNvbmNhdCBjb21tYW5kIHN0YXJ0ZWQ6ICR7Y21kfWApO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbignZW5kJywgKHN0ZG91dCwgc3RkZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtHb29nbGVUVFNdIEZGbXBlZyBjb25jYXQgY29tcGxldGVkOiAke2ZpbmFsT3V0cHV0UGF0aH1gKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RkZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW0dvb2dsZVRUU10gRkZtcGVnIGNvbmNhdCBzdGRlcnIgKHdhcm5pbmdzKTogJHtzdGRlcnJ9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ2Vycm9yJywgKGVyciwgc3Rkb3V0LCBzdGRlcnIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbR29vZ2xlVFRTXSBGRm1wZWcgY29uY2F0IEVSUk9SOmAsIGVyci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbR29vZ2xlVFRTXSBGRm1wZWcgY29uY2F0IHN0ZG91dDpgLCBzdGRvdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtHb29nbGVUVFNdIEZGbXBlZyBjb25jYXQgc3RkZXJyOmAsIHN0ZGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnJ1bigpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBDbGVhbiB1cCB0ZW1wb3JhcnkgY2h1bmsgZmlsZXMgYW5kIHRoZSBsaXN0IGZpbGUgYWZ0ZXIgc3VjY2Vzc2Z1bCBjb25jYXRlbmF0aW9uXHJcbiAgICAgICAgY29uc29sZS5sb2coYFtHb29nbGVUVFNdIENsZWFuaW5nIHVwIHRlbXBvcmFyeSBjaHVuayBmaWxlcyBhbmQgbGlzdC4uLmApO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGZzLnByb21pc2VzLnVubGluayhmaWxlTGlzdFBhdGgpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNodW5rRmlsZSBvZiB0ZW1wQ2h1bmtGaWxlcykge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgZnMucHJvbWlzZXMudW5saW5rKGNodW5rRmlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gT3B0aW9uYWxseSwgcmVtb3ZlIHRoZSBkaXJlY3RvcnkgaWYgaXQncyBlbXB0eVxyXG4gICAgICAgICAgICBmcy5ybWRpclN5bmModGVtcENvbmNhdERpcik7IC8vIFRoaXMgd2lsbCBmYWlsIGlmIGRpcmVjdG9yeSBpcyBub3QgZW1wdHksIHdoaWNoIGlzIG9rYXkuXHJcbiAgICAgICAgfSBjYXRjaCAoY2xlYW51cEVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbR29vZ2xlVFRTXSBFcnJvciBjbGVhbmluZyB1cCB0ZW1wb3JhcnkgZmlsZXM6YCwgY2xlYW51cEVycik7XHJcbiAgICAgICAgICAgIC8vIERlcGVuZGluZyBvbiB5b3VyIG5lZWRzLCB5b3UgbWlnaHQgd2FudCB0byB0aHJvdyB0aGUgZXJyb3Igb3IganVzdCBsb2cgaXQuXHJcbiAgICAgICAgICAgIC8vIEZvciBub3csIHdlIGp1c3QgbG9nIGl0IHRvIGF2b2lkIHN0b3BwaW5nIHRoZSBtYWluIHByb2Nlc3MuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhgW0dvb2dsZVRUU10gRmluYWwgY29uY2F0ZW5hdGVkIGF1ZGlvIHNhdmVkIHRvOiAke2ZpbmFsT3V0cHV0UGF0aH1gKTtcclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFtHb29nbGVUVFNdIEVycm9yIGluIGdlbmVyYXRlVFRTV2l0aEdvb2dsZVRUUzpgLCBlcnJvcik7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7IC8vIFJlLXRocm93IHRvIGJlIGNhdWdodCBieSB0aGUgbWFpbiBoYW5kbGVyXHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4vLyAtLS0gU3luYyBBZGp1c3RtZW50IEZ1bmN0aW9uOiBNYW5pcHVsYXRlIFRUUyBBdWRpbyB0byBGaXQgT3JpZ2luYWwgVmlkZW8gTGVuZ3RoIChQcmVjaXNlKSAtLS1cclxuLy8gVGhpcyBmdW5jdGlvbiBnZXRzIHRoZSBkdXJhdGlvbiBvZiB0aGUgb3JpZ2luYWwgdmlkZW8gYXVkaW8gYW5kIHRoZSBnZW5lcmF0ZWQgVFRTIGF1ZGlvLlxyXG4vLyBJdCBjYWxjdWxhdGVzIHRoZSBvdmVyYWxsIHNwZWVkIGZhY3RvciBuZWVkZWQgdG8gbWFrZSB0aGUgVFRTIGF1ZGlvIGR1cmF0aW9uIG1hdGNoIHRoZSBvcmlnaW5hbC5cclxuLy8gSXQgdGhlbiBhcHBsaWVzIHRoZSBuZWNlc3NhcnkgJ3J1YmJlcmJhbmQnIGZpbHRlciB0byBjaGFuZ2UgdGVtcG8gYW5kIGR1cmF0aW9uIHByZWNpc2VseSxcclxuLy8ga2VlcGluZyBwaXRjaCBjb25zdGFudC4gSWYgJ3J1YmJlcmJhbmQnIGlzIG5vdCBhdmFpbGFibGUsIGl0IGZhbGxzIGJhY2sgdG8gY2hhaW5lZCAnYXRlbXBvJ1xyXG4vLyBmaWx0ZXJzICgwLjUtMi4wIHJhbmdlKSBhbmQgdGhlbiBlbnN1cmVzIHRoZSBleGFjdCBkdXJhdGlvbiB1c2luZyAnYXRyaW0nIGFuZCAnYXBhZCcuXHJcbmFzeW5jIGZ1bmN0aW9uIGFkanVzdEF1ZGlvRHVyYXRpb25XaXRoRkZtcGVnKG9yaWdpbmFsQXVkaW9QYXRoLCB0dHNBdWRpb1BhdGgsIG91dHB1dFBhdGgpIHtcclxuICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coYFske3BhdGguYmFzZW5hbWUob3V0cHV0UGF0aCwgJy5tcDMnKX1dIFN0YXJ0aW5nIHByZWNpc2UgYXVkaW8gZHVyYXRpb24gYWRqdXN0bWVudCB0byBtYXRjaCBvcmlnaW5hbC4uLmApO1xyXG5cclxuICAgICAgLy8gMS4gR2V0IG9yaWdpbmFsIGF1ZGlvIGR1cmF0aW9uIHVzaW5nIGZmcHJvYmVcclxuICAgICAgY29uc29sZS5sb2coYFske3BhdGguYmFzZW5hbWUob3V0cHV0UGF0aCwgJy5tcDMnKX1dIEdldHRpbmcgb3JpZ2luYWwgYXVkaW8gZHVyYXRpb24gZnJvbTogJHtvcmlnaW5hbEF1ZGlvUGF0aH1gKTtcclxuICAgICAgY29uc3Qgb3JpZ2luYWxEdXJhdGlvbkNvbW1hbmQgPSBgZmZwcm9iZSAtdiBxdWlldCAtc2hvd19lbnRyaWVzIGZvcm1hdD1kdXJhdGlvbiAtb2YgY3N2PXA9MCBcIiR7b3JpZ2luYWxBdWRpb1BhdGh9XCJgO1xyXG4gICAgICBjb25zdCB7IHN0ZG91dDogb3JpZ2luYWxEdXJhdGlvbk91dHB1dCB9ID0gYXdhaXQgZXhlY0FzeW5jKG9yaWdpbmFsRHVyYXRpb25Db21tYW5kKTtcclxuICAgICAgY29uc3Qgb3JpZ2luYWxEdXJhdGlvbiA9IHBhcnNlRmxvYXQob3JpZ2luYWxEdXJhdGlvbk91dHB1dC50cmltKCkpO1xyXG4gICAgICBpZiAoaXNOYU4ob3JpZ2luYWxEdXJhdGlvbikgfHwgb3JpZ2luYWxEdXJhdGlvbiA8PSAwKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgb3JpZ2luYWwgZHVyYXRpb24gcmV0cmlldmVkOiAke29yaWdpbmFsRHVyYXRpb25PdXRwdXQudHJpbSgpfWApO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtwYXRoLmJhc2VuYW1lKG91dHB1dFBhdGgsICcubXAzJyl9XSBPcmlnaW5hbCBhdWRpbyBkdXJhdGlvbjogJHtvcmlnaW5hbER1cmF0aW9uLnRvRml4ZWQoMyl9c2ApO1xyXG5cclxuICAgICAgLy8gMi4gR2V0IFRUUyBhdWRpbyBkdXJhdGlvbiB1c2luZyBmZnByb2JlXHJcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtwYXRoLmJhc2VuYW1lKG91dHB1dFBhdGgsICcubXAzJyl9XSBHZXR0aW5nIFRUUyBhdWRpbyBkdXJhdGlvbiBmcm9tOiAke3R0c0F1ZGlvUGF0aH1gKTtcclxuICAgICAgY29uc3QgdHRzRHVyYXRpb25Db21tYW5kID0gYGZmcHJvYmUgLXYgcXVpZXQgLXNob3dfZW50cmllcyBmb3JtYXQ9ZHVyYXRpb24gLW9mIGNzdj1wPTAgXCIke3R0c0F1ZGlvUGF0aH1cImA7XHJcbiAgICAgIGNvbnN0IHsgc3Rkb3V0OiB0dHNEdXJhdGlvbk91dHB1dCB9ID0gYXdhaXQgZXhlY0FzeW5jKHR0c0R1cmF0aW9uQ29tbWFuZCk7XHJcbiAgICAgIGNvbnN0IHR0c0R1cmF0aW9uID0gcGFyc2VGbG9hdCh0dHNEdXJhdGlvbk91dHB1dC50cmltKCkpO1xyXG4gICAgICBpZiAoaXNOYU4odHRzRHVyYXRpb24pIHx8IHR0c0R1cmF0aW9uIDw9IDApIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBUVFMgZHVyYXRpb24gcmV0cmlldmVkOiAke3R0c0R1cmF0aW9uT3V0cHV0LnRyaW0oKX1gKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zb2xlLmxvZyhgWyR7cGF0aC5iYXNlbmFtZShvdXRwdXRQYXRoLCAnLm1wMycpfV0gVFRTIGF1ZGlvIGR1cmF0aW9uOiAke3R0c0R1cmF0aW9uLnRvRml4ZWQoMyl9c2ApO1xyXG5cclxuICAgICAgLy8gMy4gQ2FsY3VsYXRlIG92ZXJhbGwgc3BlZWQgZmFjdG9yIG5lZWRlZCAodGFyZ2V0X2R1cmF0aW9uIC8gY3VycmVudF9kdXJhdGlvbilcclxuICAgICAgY29uc3Qgb3ZlcmFsbFNwZWVkRmFjdG9yID0gb3JpZ2luYWxEdXJhdGlvbiAvIHR0c0R1cmF0aW9uO1xyXG4gICAgICBjb25zb2xlLmxvZyhgWyR7cGF0aC5iYXNlbmFtZShvdXRwdXRQYXRoLCAnLm1wMycpfV0gT3ZlcmFsbCBzcGVlZCBmYWN0b3IgbmVlZGVkIChvcmlnaW5hbC90dHMpOiAke292ZXJhbGxTcGVlZEZhY3Rvci50b0ZpeGVkKDQpfWApO1xyXG5cclxuICAgICAgLy8gLS0tIE1ldGhvZCAxOiBBdHRlbXB0IHVzaW5nICdydWJiZXJiYW5kJyBmb3IgcHJlY2lzZSBkdXJhdGlvbiBtYXRjaGluZyAtLS1cclxuICAgICAgLy8gUnViYmVyYmFuZCBpcyBnZW5lcmFsbHkgYmV0dGVyIGZvciB0ZW1wby9waXRjaCBzaGlmdGluZyB3aXRoIHF1YWxpdHkuXHJcbiAgICAgIC8vIEl0IGNhbiBkaXJlY3RseSB0YXJnZXQgYSBkdXJhdGlvbiBvciB0ZW1wbyBjaGFuZ2UuXHJcbiAgICAgIGNvbnN0IHRhcmdldFRlbXBvID0gMS4wIC8gb3ZlcmFsbFNwZWVkRmFjdG9yOyAvLyBJZiBzcGVlZCBuZWVkcyB0byBiZSAxLjJ4LCB0ZW1wbyBzaG91bGQgYmUgMS8xLjIgPSAwLjgzM3hcclxuICAgICAgY29uc29sZS5sb2coYFske3BhdGguYmFzZW5hbWUob3V0cHV0UGF0aCwgJy5tcDMnKX1dIENhbGN1bGF0ZWQgdGFyZ2V0IHRlbXBvIGZvciBydWJiZXJiYW5kOiAke3RhcmdldFRlbXBvLnRvRml4ZWQoNCl9eGApO1xyXG5cclxuICAgICAgY29uc3QgcnViYmVyYmFuZENvbW1hbmQgPSBgZmZtcGVnIC1pIFwiJHt0dHNBdWRpb1BhdGh9XCIgLWFmIFwicnViYmVyYmFuZD10ZW1wbz0ke3RhcmdldFRlbXBvLnRvRml4ZWQoNCl9XCIgLXkgXCIke291dHB1dFBhdGh9XCJgO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgWyR7cGF0aC5iYXNlbmFtZShvdXRwdXRQYXRoLCAnLm1wMycpfV0gQXR0ZW1wdGluZyBhZGp1c3RtZW50IHdpdGggcnViYmVyYmFuZDogJHtydWJiZXJiYW5kQ29tbWFuZH1gKTtcclxuICAgICAgICBjb25zdCB7IHN0ZG91dDogcmJTdGRvdXQsIHN0ZGVycjogcmJTdGRlcnIgfSA9IGF3YWl0IGV4ZWNBc3luYyhydWJiZXJiYW5kQ29tbWFuZCk7XHJcbiAgICAgICAgaWYgKHJiU3RkZXJyKSB7XHJcbiAgICAgICAgICAgIC8vIFJ1YmJlcmJhbmQgbWlnaHQgb3V0cHV0IHdhcm5pbmdzL2luZm8gaGVyZSwgbG9nIHRoZW0uXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgWyR7cGF0aC5iYXNlbmFtZShvdXRwdXRQYXRoLCAnLm1wMycpfV0gRkZtcGVnIHJ1YmJlcmJhbmQgc3RkZXJyICh3YXJuaW5ncy9pbmZvKTogJHtyYlN0ZGVycn1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5sb2coYFske3BhdGguYmFzZW5hbWUob3V0cHV0UGF0aCwgJy5tcDMnKX1dIFJ1YmJlcmJhbmQgYWRqdXN0bWVudCBjb21wbGV0ZWQuYCk7XHJcbiAgICAgICAgLy8gSWYgcnViYmVyYmFuZCBjb21tYW5kIHN1Y2NlZWRzLCB0aGUgZmlsZSBzaG91bGQgYmUgYXQgdGhlIHRhcmdldCBkdXJhdGlvbi5cclxuICAgICAgICAvLyBXZSBjYW4gb3B0aW9uYWxseSB2ZXJpZnkgdGhlIGR1cmF0aW9uIGhlcmUgYW5kIGNvcnJlY3QgZnVydGhlciBpZiBuZWVkZWQuXHJcbiAgICAgICAgLy8gRm9yIG5vdywgYXNzdW1lIGl0IHdvcmtlZCBhbmQgcmVzb2x2ZS5cclxuICAgICAgICBjb25zb2xlLmxvZyhgWyR7cGF0aC5iYXNlbmFtZShvdXRwdXRQYXRoLCAnLm1wMycpfV0gQXVkaW8gZHVyYXRpb24gYWRqdXN0bWVudCAodXNpbmcgcnViYmVyYmFuZCkgY29tcGxldGVkOiAke291dHB1dFBhdGh9YCk7XHJcbiAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIHJldHVybjsgLy8gRXhpdCB0aGUgZnVuY3Rpb24gYWZ0ZXIgc3VjY2Vzc2Z1bCBydWJiZXJiYW5kIGFkanVzdG1lbnRcclxuXHJcbiAgICAgIH0gY2F0Y2ggKHJiRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oYFske3BhdGguYmFzZW5hbWUob3V0cHV0UGF0aCwgJy5tcDMnKX1dIEZGbXBlZyBydWJiZXJiYW5kIGZhaWxlZCAobWlnaHQgbm90IGJlIGF2YWlsYWJsZSBvciBzdXBwb3J0ZWQpOmAsIHJiRXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coYFske3BhdGguYmFzZW5hbWUob3V0cHV0UGF0aCwgJy5tcDMnKX1dIEZhbGxpbmcgYmFjayB0byBjaGFpbmVkICdhdGVtcG8nIG1ldGhvZC4uLmApO1xyXG4gICAgICAgIC8vIElmIHJ1YmJlcmJhbmQgZmFpbHMsIHByb2NlZWQgdG8gdGhlIGZhbGxiYWNrIG1ldGhvZCBiZWxvdy5cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gLS0tIEZhbGxiYWNrIE1ldGhvZCAyOiBDaGFpbmVkICdhdGVtcG8nICsgRHVyYXRpb24gVmVyaWZpY2F0aW9uICsgQ29ycmVjdGlvbiAtLS1cclxuICAgICAgLy8gVGhpcyBoYW5kbGVzIGNhc2VzIHdoZXJlIHJ1YmJlcmJhbmQgaXNuJ3QgYXZhaWxhYmxlLlxyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBzZXF1ZW5jZSBvZiAnYXRlbXBvJyBmaWx0ZXJzIHJlcXVpcmVkIChyYW5nZSAwLjUgdG8gMi4wIHBlciBmaWx0ZXIpXHJcbiAgICAgIGxldCBhdGVtcG9GaWx0ZXJzID0gW107XHJcbiAgICAgIGxldCB0ZW1wRmFjdG9yID0gb3ZlcmFsbFNwZWVkRmFjdG9yO1xyXG5cclxuICAgICAgaWYgKHRlbXBGYWN0b3IgPiAxKSB7XHJcbiAgICAgICAgICAvLyBTcGVlZGluZyB1cDogVXNlIGZhY3RvcnMgdXAgdG8gMi4wXHJcbiAgICAgICAgICB3aGlsZSAodGVtcEZhY3RvciA+IDEpIHtcclxuICAgICAgICAgICAgICBjb25zdCBuZXh0RmFjdG9yID0gTWF0aC5taW4oMi4wLCB0ZW1wRmFjdG9yKTtcclxuICAgICAgICAgICAgICBhdGVtcG9GaWx0ZXJzLnB1c2gobmV4dEZhY3Rvcik7XHJcbiAgICAgICAgICAgICAgdGVtcEZhY3RvciAvPSBuZXh0RmFjdG9yO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHRlbXBGYWN0b3IgPCAxKSB7XHJcbiAgICAgICAgICAvLyBTbG93aW5nIGRvd246IFVzZSBmYWN0b3JzIGRvd24gdG8gMC41XHJcbiAgICAgICAgICB3aGlsZSAodGVtcEZhY3RvciA8IDEpIHtcclxuICAgICAgICAgICAgICBjb25zdCBuZXh0RmFjdG9yID0gTWF0aC5tYXgoMC41LCB0ZW1wRmFjdG9yKTtcclxuICAgICAgICAgICAgICBhdGVtcG9GaWx0ZXJzLnB1c2gobmV4dEZhY3Rvcik7XHJcbiAgICAgICAgICAgICAgdGVtcEZhY3RvciAvPSBuZXh0RmFjdG9yO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBhdGVtcG9GaWx0ZXJTdHJpbmcgPSBhdGVtcG9GaWx0ZXJzLm1hcChmID0+IGBhdGVtcG89JHtmLnRvRml4ZWQoMil9YCkuam9pbignLCcpO1xyXG4gICAgICBjb25zb2xlLmxvZyhgWyR7cGF0aC5iYXNlbmFtZShvdXRwdXRQYXRoLCAnLm1wMycpfV0gQ2FsY3VsYXRlZCBhdGVtcG8gZmlsdGVycyBmb3IgZmFsbGJhY2s6ICR7YXRlbXBvRmlsdGVyU3RyaW5nIHx8ICdOb25lIChmYWN0b3IgaXMgMS4wKSd9YCk7XHJcblxyXG4gICAgICBjb25zdCB0ZW1wQWRqdXN0ZWRQYXRoID0gYCR7b3V0cHV0UGF0aH0udGVtcF9hdGVtcG8ubXAzYDsgLy8gVGVtcG9yYXJ5IGZpbGUgZm9yIGF0ZW1wbyBvdXRwdXRcclxuICAgICAgbGV0IGF0ZW1wb0NvbW1hbmQ7XHJcbiAgICAgIGlmIChhdGVtcG9GaWx0ZXJTdHJpbmcpIHtcclxuICAgICAgICAgIGF0ZW1wb0NvbW1hbmQgPSBgZmZtcGVnIC1pIFwiJHt0dHNBdWRpb1BhdGh9XCIgLWFmIFwiJHthdGVtcG9GaWx0ZXJTdHJpbmd9XCIgLXkgXCIke3RlbXBBZGp1c3RlZFBhdGh9XCJgO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gSWYgbm8gYWRqdXN0bWVudCBuZWVkZWQsIGp1c3QgY29weVxyXG4gICAgICAgICAgY29uc29sZS5sb2coYFske3BhdGguYmFzZW5hbWUob3V0cHV0UGF0aCwgJy5tcDMnKX1dIE5vIGF0ZW1wbyBhZGp1c3RtZW50IG5lZWRlZCAoZmFjdG9yIGlzIDEuMCksIGNvcHlpbmcuLi5gKTtcclxuICAgICAgICAgIGF0ZW1wb0NvbW1hbmQgPSBgZmZtcGVnIC1pIFwiJHt0dHNBdWRpb1BhdGh9XCIgLWMgY29weSAteSBcIiR7dGVtcEFkanVzdGVkUGF0aH1cImA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtwYXRoLmJhc2VuYW1lKG91dHB1dFBhdGgsICcubXAzJyl9XSBFeGVjdXRpbmcgYXRlbXBvIGNvbW1hbmQ6ICR7YXRlbXBvQ29tbWFuZH1gKTtcclxuICAgICAgY29uc3QgeyBzdGRvdXQ6IGF0ZW1wb1N0ZG91dCwgc3RkZXJyOiBhdGVtcG9TdGRlcnIgfSA9IGF3YWl0IGV4ZWNBc3luYyhhdGVtcG9Db21tYW5kKTtcclxuICAgICAgaWYgKGF0ZW1wb1N0ZGVycikge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKGBbJHtwYXRoLmJhc2VuYW1lKG91dHB1dFBhdGgsICcubXAzJyl9XSBGRm1wZWcgYXRlbXBvIHN0ZGVyciAod2FybmluZ3MvaW5mbyk6ICR7YXRlbXBvU3RkZXJyfWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyAtLS0gVmVyaWZ5IER1cmF0aW9uIGFuZCBDb3JyZWN0IC0tLVxyXG4gICAgICAvLyBHZXQgdGhlIGR1cmF0aW9uIG9mIHRoZSBmaWxlIGFmdGVyIGF0ZW1wbyBhZGp1c3RtZW50XHJcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtwYXRoLmJhc2VuYW1lKG91dHB1dFBhdGgsICcubXAzJyl9XSBWZXJpZnlpbmcgZHVyYXRpb24gb2YgYXRlbXBvLWFkanVzdGVkIGZpbGU6ICR7dGVtcEFkanVzdGVkUGF0aH1gKTtcclxuICAgICAgY29uc3QgYWRqdXN0ZWREdXJhdGlvbkNvbW1hbmQgPSBgZmZwcm9iZSAtdiBxdWlldCAtc2hvd19lbnRyaWVzIGZvcm1hdD1kdXJhdGlvbiAtb2YgY3N2PXA9MCBcIiR7dGVtcEFkanVzdGVkUGF0aH1cImA7XHJcbiAgICAgIGNvbnN0IHsgc3Rkb3V0OiBhZGp1c3RlZER1cmF0aW9uT3V0cHV0IH0gPSBhd2FpdCBleGVjQXN5bmMoYWRqdXN0ZWREdXJhdGlvbkNvbW1hbmQpO1xyXG4gICAgICBjb25zdCBhZGp1c3RlZER1cmF0aW9uID0gcGFyc2VGbG9hdChhZGp1c3RlZER1cmF0aW9uT3V0cHV0LnRyaW0oKSk7XHJcbiAgICAgIGlmIChpc05hTihhZGp1c3RlZER1cmF0aW9uKSB8fCBhZGp1c3RlZER1cmF0aW9uIDw9IDApIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkdXJhdGlvbiByZXRyaWV2ZWQgZnJvbSBhZGp1c3RlZCBmaWxlOiAke2FkanVzdGVkRHVyYXRpb25PdXRwdXQudHJpbSgpfWApO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtwYXRoLmJhc2VuYW1lKG91dHB1dFBhdGgsICcubXAzJyl9XSBEdXJhdGlvbiBhZnRlciBhdGVtcG86ICR7YWRqdXN0ZWREdXJhdGlvbi50b0ZpeGVkKDMpfXMsIFRhcmdldDogJHtvcmlnaW5hbER1cmF0aW9uLnRvRml4ZWQoMyl9c2ApO1xyXG5cclxuICAgICAgY29uc3QgZHVyYXRpb25EaWZmID0gb3JpZ2luYWxEdXJhdGlvbiAtIGFkanVzdGVkRHVyYXRpb247XHJcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtwYXRoLmJhc2VuYW1lKG91dHB1dFBhdGgsICcubXAzJyl9XSBEdXJhdGlvbiBkaWZmZXJlbmNlICh0YXJnZXQgLSBhZGp1c3RlZCk6ICR7ZHVyYXRpb25EaWZmLnRvRml4ZWQoMyl9c2ApO1xyXG5cclxuICAgICAgLy8gTm93LCBhcHBseSBhIGZpbmFsIGZpbHRlciB0byBlbnN1cmUgdGhlIGV4YWN0IGR1cmF0aW9uIG1hdGNoZXMgdGhlIG9yaWdpbmFsXHJcbiAgICAgIC8vIElmIGl0J3MgdG9vIHNob3J0IChkdXJhdGlvbkRpZmYgPiAwKSwgdXNlICdhcGFkJyB0byBhZGQgc2lsZW5jZSBhdCB0aGUgZW5kLlxyXG4gICAgICAvLyBJZiBpdCdzIHRvbyBsb25nIChkdXJhdGlvbkRpZmYgPCAwKSwgdXNlICdhdHJpbScgdG8gY3V0IHRoZSBlbmQuXHJcbiAgICAgIC8vIElmIGl0J3MgdmVyeSBjbG9zZSAoZS5nLiwgd2l0aGluIDAuMDFzKSwganVzdCBjb3B5IG9yIHJlbmFtZS5cclxuICAgICAgY29uc3QgdG9sZXJhbmNlID0gMC4wMTsgLy8gMTAgbWlsbGlzZWNvbmRzIHRvbGVyYW5jZVxyXG5cclxuICAgICAgaWYgKE1hdGguYWJzKGR1cmF0aW9uRGlmZikgPCB0b2xlcmFuY2UpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtwYXRoLmJhc2VuYW1lKG91dHB1dFBhdGgsICcubXAzJyl9XSBEdXJhdGlvbiBpcyB3aXRoaW4gdG9sZXJhbmNlICgke3RvbGVyYW5jZX1zKSwgbm8gZnVydGhlciBhZGp1c3RtZW50IG5lZWRlZC5gKTtcclxuICAgICAgICAgIC8vIE1vdmUgdGhlIHRlbXBvcmFyeSBmaWxlIHRvIHRoZSBmaW5hbCBvdXRwdXQgcGF0aFxyXG4gICAgICAgICAgYXdhaXQgZnMucHJvbWlzZXMucmVuYW1lKHRlbXBBZGp1c3RlZFBhdGgsIG91dHB1dFBhdGgpO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYFske3BhdGguYmFzZW5hbWUob3V0cHV0UGF0aCwgJy5tcDMnKX1dIEF1ZGlvIGR1cmF0aW9uIGFkanVzdG1lbnQgY29tcGxldGVkICh3aXRoaW4gdG9sZXJhbmNlKTogJHtvdXRwdXRQYXRofWApO1xyXG4gICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgZmluYWxDb21tYW5kO1xyXG4gICAgICBpZiAoZHVyYXRpb25EaWZmID4gdG9sZXJhbmNlKSB7XHJcbiAgICAgICAgICAvLyBBdWRpbyBpcyB0b28gc2hvcnQsIHBhZCB3aXRoIHNpbGVuY2VcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtwYXRoLmJhc2VuYW1lKG91dHB1dFBhdGgsICcubXAzJyl9XSBBdWRpbyBpcyB0b28gc2hvcnQsIHBhZGRpbmcgd2l0aCAke2R1cmF0aW9uRGlmZi50b0ZpeGVkKDMpfXMgb2Ygc2lsZW5jZS5gKTtcclxuICAgICAgICAgIGZpbmFsQ29tbWFuZCA9IGBmZm1wZWcgLWkgXCIke3RlbXBBZGp1c3RlZFBhdGh9XCIgLWFmIFwiYXBhZD1wYWRfZHVyPSR7ZHVyYXRpb25EaWZmLnRvRml4ZWQoMyl9XCIgLXkgXCIke291dHB1dFBhdGh9XCJgO1xyXG4gICAgICB9IGVsc2UgaWYgKGR1cmF0aW9uRGlmZiA8IC10b2xlcmFuY2UpIHtcclxuICAgICAgICAgIC8vIEF1ZGlvIGlzIHRvbyBsb25nLCB0cmltIHRoZSBlbmRcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtwYXRoLmJhc2VuYW1lKG91dHB1dFBhdGgsICcubXAzJyl9XSBBdWRpbyBpcyB0b28gbG9uZywgdHJpbW1pbmcgJHtNYXRoLmFicyhkdXJhdGlvbkRpZmYpLnRvRml4ZWQoMyl9cyBmcm9tIHRoZSBlbmQuYCk7XHJcbiAgICAgICAgICBmaW5hbENvbW1hbmQgPSBgZmZtcGVnIC1pIFwiJHt0ZW1wQWRqdXN0ZWRQYXRofVwiIC10byAke29yaWdpbmFsRHVyYXRpb24udG9GaXhlZCgzKX0gLWMgY29weSAteSBcIiR7b3V0cHV0UGF0aH1cImA7XHJcbiAgICAgICAgICAvLyBBbHRlcm5hdGl2ZSB1c2luZyBhdHJpbSBmaWx0ZXI6IGZpbmFsQ29tbWFuZCA9IGBmZm1wZWcgLWkgXCIke3RlbXBBZGp1c3RlZFBhdGh9XCIgLWFmIFwiYXRyaW09ZW5kPSR7b3JpZ2luYWxEdXJhdGlvbi50b0ZpeGVkKDMpfVwiIC15IFwiJHtvdXRwdXRQYXRofVwiYDtcclxuICAgICAgICAgIC8vIFVzaW5nIC10byB3aXRoIC1jIGNvcHkgaXMgb2Z0ZW4gZmFzdGVyIHRoYW4gcmUtZW5jb2Rpbmcgd2l0aCBhdHJpbS5cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGZpbmFsQ29tbWFuZCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYFske3BhdGguYmFzZW5hbWUob3V0cHV0UGF0aCwgJy5tcDMnKX1dIEV4ZWN1dGluZyBmaW5hbCBjb3JyZWN0aW9uIGNvbW1hbmQ6ICR7ZmluYWxDb21tYW5kfWApO1xyXG4gICAgICAgICAgY29uc3QgeyBzdGRvdXQ6IGZpbmFsU3Rkb3V0LCBzdGRlcnI6IGZpbmFsU3RkZXJyIH0gPSBhd2FpdCBleGVjQXN5bmMoZmluYWxDb21tYW5kKTtcclxuICAgICAgICAgIGlmIChmaW5hbFN0ZGVycikge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihgWyR7cGF0aC5iYXNlbmFtZShvdXRwdXRQYXRoLCAnLm1wMycpfV0gRkZtcGVnIGZpbmFsIGNvcnJlY3Rpb24gc3RkZXJyICh3YXJuaW5ncy9pbmZvKTogJHtmaW5hbFN0ZGVycn1gKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2xlYW4gdXAgdGhlIHRlbXBvcmFyeSBhdGVtcG8gZmlsZVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgICAgYXdhaXQgZnMucHJvbWlzZXMudW5saW5rKHRlbXBBZGp1c3RlZFBhdGgpO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYFske3BhdGguYmFzZW5hbWUob3V0cHV0UGF0aCwgJy5tcDMnKX1dIERlbGV0ZWQgdGVtcG9yYXJ5IGF0ZW1wbyBmaWxlOiAke3RlbXBBZGp1c3RlZFBhdGh9YCk7XHJcbiAgICAgIH0gY2F0Y2ggKHVubGlua0Vycikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgWyR7cGF0aC5iYXNlbmFtZShvdXRwdXRQYXRoLCAnLm1wMycpfV0gRXJyb3IgZGVsZXRpbmcgdGVtcG9yYXJ5IGZpbGU6YCwgdW5saW5rRXJyKTtcclxuICAgICAgICAgIC8vIERlcGVuZGluZyBvbiByZXF1aXJlbWVudHMsIHRoaXMgbWlnaHQgYmUgYSB3YXJuaW5nIG9yIGFuIGVycm9yLlxyXG4gICAgICAgICAgLy8gRm9yIG5vdywgd2UgY29udGludWUgZXZlbiBpZiBkZWxldGlvbiBmYWlscy5cclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5sb2coYFske3BhdGguYmFzZW5hbWUob3V0cHV0UGF0aCwgJy5tcDMnKX1dIEF1ZGlvIGR1cmF0aW9uIGFkanVzdG1lbnQgY29tcGxldGVkICh3aXRoIGNvcnJlY3Rpb24pOiAke291dHB1dFBhdGh9YCk7XHJcbiAgICAgIHJlc29sdmUoKTsgLy8gUmVzb2x2ZSB0aGUgcHJvbWlzZSBvbiBzdWNjZXNzZnVsIGNvbXBsZXRpb25cclxuXHJcbiAgICB9IGNhdGNoIChleGVjRXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgWyR7cGF0aC5iYXNlbmFtZShvdXRwdXRQYXRoLCAnLm1wMycpfV0gRkZtcGVnIGV4ZWMgRXJyb3IgaW4gYWRqdXN0QXVkaW9EdXJhdGlvbldpdGhGRm1wZWc6YCwgZXhlY0Vycm9yKTtcclxuICAgICAgaWYgKGV4ZWNFcnJvci5zdGRvdXQpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFske3BhdGguYmFzZW5hbWUob3V0cHV0UGF0aCwgJy5tcDMnKX1dIEZGbXBlZyBzdGRvdXQgb24gZXJyb3I6YCwgZXhlY0Vycm9yLnN0ZG91dCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGV4ZWNFcnJvci5zdGRlcnIpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFske3BhdGguYmFzZW5hbWUob3V0cHV0UGF0aCwgJy5tcDMnKX1dIEZGbXBlZyBzdGRlcnIgb24gZXJyb3I6YCwgZXhlY0Vycm9yLnN0ZGVycik7XHJcbiAgICAgIH1cclxuICAgICAgLy8gQXR0ZW1wdCB0byBjbGVhbiB1cCB0aGUgdGVtcG9yYXJ5IGZpbGUgaWYgaXQgZXhpc3RzIGluIGNhc2Ugb2YgYW4gZXJyb3JcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAgIGF3YWl0IGZzLnByb21pc2VzLnVubGluayhgJHtvdXRwdXRQYXRofS50ZW1wX2F0ZW1wby5tcDNgKTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtwYXRoLmJhc2VuYW1lKG91dHB1dFBhdGgsICcubXAzJyl9XSBEZWxldGVkIHRlbXBvcmFyeSBhdGVtcG8gZmlsZSBvbiBlcnJvci5gKTtcclxuICAgICAgfSBjYXRjaCAodW5saW5rRXJyKSB7XHJcbiAgICAgICAgICAvLyBJZ25vcmUgZXJyb3IgZHVyaW5nIGNsZWFudXAgb24gZXJyb3IgcGF0aFxyXG4gICAgICB9XHJcbiAgICAgIHJlamVjdChleGVjRXJyb3IpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJmcyIsInBhdGgiLCJmZm1wZWciLCJleGVjIiwicHJvbWlzaWZ5IiwiR29vZ2xlR2VuZXJhdGl2ZUFJIiwiZXhlY0FzeW5jIiwiY29uZmlnIiwiYXBpIiwicmVzcG9uc2VMaW1pdCIsImJvZHlQYXJzZXIiLCJoYW5kbGVyIiwicmVxIiwicmVzIiwibWV0aG9kIiwic3RhdHVzIiwianNvbiIsIm1lc3NhZ2UiLCJib2R5Iiwib24iLCJjaHVuayIsInRvU3RyaW5nIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJ2aWRlb0lkIiwic291cmNlTGFuZyIsInRhcmdldExhbmciLCJwYXJzZWRCb2R5IiwiSlNPTiIsInBhcnNlIiwiZSIsImNvbnNvbGUiLCJlcnJvciIsInRlbXBEaXIiLCJqb2luIiwicHJvY2VzcyIsImN3ZCIsIm1ldGFkYXRhUGF0aCIsInZpZGVvUGF0aCIsImV4aXN0c1N5bmMiLCJsb2ciLCJhdWRpb1BhdGgiLCJ0b0Zvcm1hdCIsImF1ZGlvQ2hhbm5lbHMiLCJhdWRpb0ZyZXF1ZW5jeSIsIm91dHB1dCIsImVyciIsInJ1biIsImR1YmJlZEF1ZGlvUGF0aF9NUDMiLCJkdWJiZWRBdWRpb1BhdGhBZGp1c3RlZF9NUDMiLCJ0cmFuc2NyaWJlZFRleHQiLCJ0cmFuc2NyaWJlQXVkaW9XaXRoQXNzZW1ibHlBSSIsInRyYW5zbGF0ZWRUZXh0IiwidHJhbnNsYXRlV2l0aEdlbWluaSIsImdlbmVyYXRlVFRTV2l0aEVsZXZlbkxhYnMiLCJhZGp1c3RBdWRpb0R1cmF0aW9uV2l0aEZGbXBlZyIsIm91dHB1dFBhdGgiLCJmZm1wZWdDb21tYW5kIiwiaW5wdXQiLCJvdXRwdXRPcHRpb25zIiwiY21kIiwicHJvZ3Jlc3MiLCJzdGRvdXQiLCJzdGRlcnIiLCJ3YXJuIiwidW5saW5rIiwibWV0YWRhdGEiLCJwcm9taXNlcyIsInJlYWRGaWxlIiwicHJvY2Vzc2VkVGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwid3JpdGVGaWxlIiwic3RyaW5naWZ5IiwibWV0YUVyciIsImF1ZGlvRmlsZVBhdGgiLCJBU1NFTUJMWUFJX0FQSV9LRVkiLCJlbnYiLCJFcnJvciIsImVuZHBvaW50IiwiYXVkaW9EYXRhIiwicmVhZEZpbGVTeW5jIiwidXBsb2FkUmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJvayIsImVycm9yVGV4dCIsInRleHQiLCJ1cGxvYWREYXRhIiwiYXVkaW9VcmwiLCJ1cGxvYWRfdXJsIiwidHJhbnNjcmliZVJlc3BvbnNlIiwiYXVkaW9fdXJsIiwidHJhbnNjcmliZURhdGEiLCJ0cmFuc2NyaXB0SWQiLCJpZCIsInBvbGxpbmdFbmRwb2ludCIsInJlc3VsdCIsInBvbGxSZXNwb25zZSIsInNldFRpbWVvdXQiLCJ1bmRlZmluZWQiLCJjb25maWRlbmNlIiwidHJpbSIsIkdFTUlOSV9BUElfS0VZIiwiZ2VuQUkiLCJtb2RlbCIsImdldEdlbmVyYXRpdmVNb2RlbCIsInByb21wdCIsImdlbmVyYXRlQ29udGVudCIsInJlc3BvbnNlIiwiRUxFVkVOTEFCU19BUElfS0VZIiwiZ2VuZXJhdGVUVFNXaXRoRWxldmVuTGFic0FQSSIsImdlbmVyYXRlVFRTV2l0aEdvb2dsZVRUUyIsImFwaUtleSIsInZvaWNlSWRNYXAiLCJ2b2ljZUlkIiwib3V0cHV0Rm9ybWF0IiwidXJsIiwicmVxdWVzdEJvZHkiLCJzdWJzdHJpbmciLCJzdGF0dXNUZXh0IiwiYXVkaW9CdWZmZXIiLCJCdWZmZXIiLCJmcm9tIiwiYXJyYXlCdWZmZXIiLCJ0cmFuc2xhdGUiLCJyZXF1aXJlIiwibGFuZyIsImF1ZGlvVXJscyIsImdldEFsbEF1ZGlvVXJscyIsInNsb3ciLCJob3N0IiwidGltZW91dCIsImxlbmd0aCIsImF1ZGlvQnVmZmVycyIsImkiLCJjaHVua1VybCIsImJ1ZmZlciIsInB1c2giLCJ0ZW1wQ29uY2F0RGlyIiwibWtkaXJTeW5jIiwicmVjdXJzaXZlIiwidGVtcENodW5rRmlsZXMiLCJjaHVua0ZpbGVOYW1lIiwibm93IiwiY2h1bmtGaWxlUGF0aCIsImZpbGVMaXN0UGF0aCIsImZpbGVMaXN0Q29udGVudCIsIm1hcCIsImZpbGUiLCJmaW5hbE91dHB1dFBhdGgiLCJpbnB1dE9wdGlvbnMiLCJjaHVua0ZpbGUiLCJybWRpclN5bmMiLCJjbGVhbnVwRXJyIiwib3JpZ2luYWxBdWRpb1BhdGgiLCJ0dHNBdWRpb1BhdGgiLCJiYXNlbmFtZSIsIm9yaWdpbmFsRHVyYXRpb25Db21tYW5kIiwib3JpZ2luYWxEdXJhdGlvbk91dHB1dCIsIm9yaWdpbmFsRHVyYXRpb24iLCJwYXJzZUZsb2F0IiwiaXNOYU4iLCJ0b0ZpeGVkIiwidHRzRHVyYXRpb25Db21tYW5kIiwidHRzRHVyYXRpb25PdXRwdXQiLCJ0dHNEdXJhdGlvbiIsIm92ZXJhbGxTcGVlZEZhY3RvciIsInRhcmdldFRlbXBvIiwicnViYmVyYmFuZENvbW1hbmQiLCJyYlN0ZG91dCIsInJiU3RkZXJyIiwicmJFcnJvciIsImF0ZW1wb0ZpbHRlcnMiLCJ0ZW1wRmFjdG9yIiwibmV4dEZhY3RvciIsIk1hdGgiLCJtaW4iLCJtYXgiLCJhdGVtcG9GaWx0ZXJTdHJpbmciLCJmIiwidGVtcEFkanVzdGVkUGF0aCIsImF0ZW1wb0NvbW1hbmQiLCJhdGVtcG9TdGRvdXQiLCJhdGVtcG9TdGRlcnIiLCJhZGp1c3RlZER1cmF0aW9uQ29tbWFuZCIsImFkanVzdGVkRHVyYXRpb25PdXRwdXQiLCJhZGp1c3RlZER1cmF0aW9uIiwiZHVyYXRpb25EaWZmIiwidG9sZXJhbmNlIiwiYWJzIiwicmVuYW1lIiwiZmluYWxDb21tYW5kIiwiZmluYWxTdGRvdXQiLCJmaW5hbFN0ZGVyciIsInVubGlua0VyciIsImV4ZWNFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./pages/api/process.js\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fprocess&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cprocess.js&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();